<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"/> -->
  <meta name="viewport" content="width=device-width,
                 initial-scale=1.0,
                 maximum-scale=1.0,
                 minimum-scale=1.0,
                 user-scalable=no">
  <title>Create Your Character</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    /* 
        body {
        display: flex;
        flex-direction: column;
        } */
  </style>





</head>

<body class="char-page">
  <!-- HEADER: 1/6 -->
  <header class="header">
    <div class="header-top">
      <div class="back-buttons">
        <button id="goBackMain" class="circle-button small blue-bg" onclick="goBack()">‚Üê</button>
        <!-- <h3 class="header-text">CREATE AN AVATAR!</h3> -->
        <button id="info-toggle" class="circle-button small yellow-bg" aria-label="info">?</button>
        <button class="text-back" onclick="goBack()">BACK TO MAIN PAGE</button>
      </div>

    </div>




    <div class="title-section">
      <div class="steps">
        <div class="step active"></div>
        <div class="step"></div>
        <div class="step"></div>
        <div class="step"></div>
      </div>
      <h1>CHOOSE YOUR CHARACTER'S BASIC OUTFIT.</h1>

      <p class="subtitle">Use the left and right arrows for each section to choose.</p>

    </div>
  </header>

  <!-- BUILDER: 4/6 -->
  <main id="avatarExport" class="builder-section">
    <div class="rig-background"></div>
    <svg id="rig" width="800" height="800" viewBox="0 0 800 800"></svg>

    <div class="head">
      <ul class="list">
        <li class="hide"></li>
        <li class="prev"></li>
        <li class="act"></li>
        <li class="next"></li>
        <li class="next new-next"></li>
      </ul>
      <div class="swipe"></div>
    </div>

    <div class="torso">
      <ul class="list">
        <li class="hide"></li>
        <li class="prev"></li>
        <li class="act"></li>
        <li class="next"></li>
        <li class="next new-next"></li>
      </ul>
      <div class="swipe"></div>
    </div>

    <div class="legs">
      <ul class="list">
        <li class="hide"></li>
        <li class="prev"></li>
        <li class="act"></li>
        <li class="next"></li>
        <li class="next new-next"></li>
      </ul>
      <div class="swipe"></div>
    </div>

    <div class="shoes">
      <ul class="list">
        <li class="hide"></li>
        <li class="prev"></li>
        <li class="act"></li>
        <li class="next"></li>
        <li class="next new-next"></li>
      </ul>
      <div class="swipe"></div>
    </div>

    <canvas id="faceCanvas"></canvas>

    <!-- LEFT PANEL (details about the character) -->
    <!-- <div class="left-panel">
  <div class="form-group">
    <label for="charName">Name your character!</label>
    <input id="charName" type="text" class="input-field" />
  </div>

  <div class="form-group">
    <label for="favThing">What is your character‚Äôs favourite thing to do in Punggol?</label>
    <textarea id="favThing" class="input-field"></textarea>
  </div>

  <div class="traits-section">
    <p>Character Traits</p>
    <div class="tags">
      <span class="tag pink">Nature Lover</span>
      <span class="tag blue">Creative</span>
      <button class="circle-button extrasmall blue-bg add-tag">+</button>
    </div>
  </div>
</div> -->

    <!-- RIGHT PANEL (consent & email) -->
    <!-- <div class="right-panel">
  <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Nihil labore, laudantium minus.</p>
  <div class="form-group">
    <label for="emailConsent">Can we send you a copy of your avatar?</label>
    <input type="checkbox" id="emailConsent" />
  </div>

  <div class="form-group">
    <label for="emailAddress">Email address</label>
    <input id="emailAddress" type="email" class="input-field" placeholder="your@email.com" />
  </div>
</div> -->


    <!-- STAGE-4 floating cards -->
    <div class="card-input name-card">
      <p>HELLO, MY NAME IS</p>
      <input type="text" id="charName" />
    </div>

    <div class="card-input fav-card">
      <p>MY FAVOURITE THING TO DO IN PUNGGOL IS</p>
      <textarea id="favThing"></textarea>
      <div class="icon">üõµ</div>
    </div>

    <!-- <div class="card-input trait-card blue">
      <span>URBAN<br />ENTHUSIAST</span>
    </div>

    <div class="card-input trait-card pink">
      <span>CYCLE LOVER</span>
    </div>

    <div class="card-input trait-card green">
      <span></span>
    </div>
    <div class="card-input trait-card yellow">
      <span></span>
    </div> -->

    <div class="card-input traits-card">
      <h3>your traits!</h3>
      <div class="traits-list">
        <div class="trait-card blue"><span><!-- hat trait --></span></div>
        <div class="trait-card pink"><span><!-- torso trait --></span></div>
        <div class="trait-card green"><span><!-- legs trait --></span></div>
        <div class="trait-card yellow"><span><!-- shoes trait --></span></div>
      </div>
    </div>


    <div class="card-input email-card">

      <div class="checkbox-row">
        <input type="checkbox" id="emailConsent" />
        <label for="emailConsent">
          I agree to receive updates and newsletters from Shaping Hearts.
        </label>
      </div>
      <!-- <p style="padding: 0%; margin: 0%;">YOUR EMAIL</p> -->
      <input type="text" id="emailAddress" placeholder="your@email.com" disabled />
      <p>
        You avatar will be emailed to the address above soon :)
      </p>
    </div>







    <div class="draw-toolbar">
      <div class="color-picker">
        <div class="color-swatch" data-color="#234ea8" style="background:#234ea8"></div>
        <div class="color-swatch" data-color="#605259" style="background:#605259"></div>
        <div class="color-swatch" data-color="#c45a48" style="background:#c45a48"></div>
        <div class="color-swatch" data-color="#859c8e" style="background:#859c8e"></div>
        <div class="color-swatch" data-color="#40904d" style="background:#40904d"></div>
      </div>
      <div class="button-row">
        <button class="arc-button" id="undoBtn">‚Ü∂</button>
        <button class="arc-button" id="clearBtn">CLEAR</button>
        <button class="arc-button" id="redoBtn">‚Ü∑</button>
      </div>


    </div>


  </main>
  <script src="https://hammerjs.github.io/dist/hammer.js"></script>

  <!-- FOOTER: 1/6 -->
  <footer class="footer-section">
    <button class="back-btn">BACK</button>
    <button class="next-btn " style="margin-left: 20px;">
      NEXT
    </button>


  </footer>

  <!-- TERMS & CONDITIONS MODAL (hidden by default) -->
  <div id="tc-modal" class="modal-overlay" style="display:none">
    <div class="modal-content">
      <button class="tc-close">&times;</button>
      <h2>Terms &amp; Conditions.</h2>
      <div class="tc-text" style="font-size:0.8rem; max-height:300px; overflow-y:auto; margin-bottom:1em">
        <p>By submitting your artwork in connection with the Shaping Hearts Placemaking Series held at the National Day
          Heartland Celebrations 2025 @ North East on 10 August 2025 organised by People‚Äôs Association as represented by
          the North East Community Development Council, you agree to the following terms:
          ¬†</p>
        <ol>
          <li><strong>Originality and Rights</strong><br />
            You warrant that: (a) the Artwork is your original creation; (b) The submission, use, and display of the
            Artwork does not and will not infringe the intellectual property or other rights of any third party.
            ¬†</li>
          <br>
          <li><strong>Ownership and IP Rights</strong><br />
            You agree that all rights, title, and interest (including all present and future intellectual property
            rights) in and to the Artwork shall vest in PA and Singapore Institute of Technology upon submission.
            ¬†
            You irrevocably and unconditionally waive and relinquish any and all rights that you may have in the Artwork
            (including moral rights), and agree not to assert any claim in connection with the Artwork against PA and/or
            SIT.</li>
          <br>
          <li><strong>Use of Artwork</strong><br />
            PA and SIT shall each have the full and unfettered right to use, reproduce, publish, adapt, modify,
            distribute, display, and communicate the Artwork in any manner and for any purpose, including marketing,
            promotional, or archival purposes, in all media and formats, whether now known or hereafter developed,
            without further notice to or permission from you and without any payment or compensation.</li>
          <br>
          <li><strong>No Further Claims</strong><br />
            You agree that you shall not make any claim against PA, SIT and/or their respective representatives in
            respect of the use of the Artwork, and release them from any liability arising from such use.</li>
        </ol>
      </div>
      <button id="tc-agree" class="red-bg">I AGREE</button>
    </div>
  </div>


  <!-- LOADING OVERLAY (hidden by default) -->
  <div id="loading-overlay" class="modal-overlay" style="display:none">
    <div class="spinner"></div>
  </div>


  <div id="custom-alert" class="custom-alert">
    <div class="custom-alert__content">
      <p id="custom-alert__message"></p>
      <div class="custom-alert__buttons">
        <button id="custom-alert__gallery">VISIT THE GALLERY <span style="font-size: 2.2rem;">üëÄ</span></button>
        <button id="custom-alert__another">MAKE ANOTHER AVATAR <span style="font-size: 2.2rem;">üé®</span></button>
        <button id="custom-alert__save">SAVE AVATAR <span style="font-size: 2.2rem;">üíæ</span></button>
        <button id="custom-alert__home">GO TO HOMEPAGE <span style="font-size: 2.2rem;">üè°</span></button>
      </div>
    </div>
  </div>







  <div class="info-card">
    <button id="info-close" class="circle-button small yellow-bg" aria-label="close info">x</button>
    <h2>FEATURING ARTWORKS BY SHAPING HEARTS ARTISTS!</h2>
    <p>Each clothing and print is built from artwork created by Shaping Hearts Artists Simeon and Ezra. Learn more
      about
      them below.</p>
    <div class="info-buttons">
      <a href="https://shapinghearts.cdc.gov.sg/simeon-tan-rui-en/" target="_blank" rel="noopener"
        class="text-back">Simeon</a>
      <a href="https://shapinghearts.cdc.gov.sg/ezra-chan-yi/" target="_blank" rel="noopener" class="text-back">Ezra</a>
    </div>
  </div>


  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>


  <script type="module">
    // 1Ô∏è‚É£ core
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-app.js";

    // 2Ô∏è‚É£ Firestore (database) APIs
    import {
      getFirestore,
      serverTimestamp,
      collection,
      addDoc,
      query,
      where,
      getDocs,
      deleteDoc,
      Timestamp
    } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-firestore.js";

    // 3Ô∏è‚É£ Storage APIs
    import {
      getStorage,
      ref,
      uploadBytes,
      getDownloadURL,
    } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-storage.js";

    // 4Ô∏è‚É£ your config (keep yours here)
    const firebaseConfig = {
      apiKey: "AIzaSyDwpNjnDFAA_5P64zMOt-GTSOdETx2xKJQ",
      authDomain: "people-of-pdd-website.firebaseapp.com",
      projectId: "people-of-pdd-website",
      storageBucket: "people-of-pdd-website.firebasestorage.app",
      messagingSenderId: "685048567158",
      appId: "1:685048567158:web:abc51754b5b785219c1657",
      measurementId: "G-1VRMYRMXKN"
    };

    // 5Ô∏è‚É£ init
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const storage = getStorage(app);

    // // test helper ‚Äî stick this anywhere after your imports
    // async function testEnqueueMail() {
    //   try {
    //     const docRef = await addDoc(
    //       collection(db, "mail"),
    //       {
    //         to: "aduneti.9626@gmail.com",
    //         message: {
    //           subject: "Test email 2 from Firebase",
    //           html: "<p>Hello from Firebase!</p>"
    //         },
    //         createdAt: serverTimestamp()
    //       }
    //     );
    //     console.log("‚úÖ Mail enqueued! Doc ID:", docRef.id);
    //   } catch (err) {
    //     console.error("‚ùå Failed to enqueue mail:", err);
    //   }
    // }

    // // call it immediately for testing
    // testEnqueueMail();




    // 6Ô∏è‚É£ expose for your non‚Äëmodule scripts
    window.db = db;
    window.storage = storage;
    window.serverTimestamp = serverTimestamp;
    window.collection = collection;
    window.addDoc = addDoc;
    window.ref = ref;
    window.uploadBytes = uploadBytes;
    window.getDownloadURL = getDownloadURL;



    async function deleteAvatarsCreatedOnAug8() {
      const start = Timestamp.fromDate(new Date('2025-08-09T00:00:00Z'));
      const end = Timestamp.fromDate(new Date('2025-08-10T00:00:00Z'));

      const avatarRef = collection(db, "galleryCharacters");
      const q = query(
        avatarRef,
        where("createdAt", ">=", start),
        where("createdAt", "<", end)
      );

      try {
        const snapshot = await getDocs(q);
        console.log(`Found ${snapshot.size} avatars to delete.`);

        snapshot.forEach(async (doc) => {
          await deleteDoc(doc.ref);
          console.log(`üóëÔ∏è Deleted: ${doc.id}`);
        });

      } catch (err) {
        console.error("‚ùå Error deleting avatars:", err);
      }
    }

    window.deleteAvatarsCreatedOnAug8 = deleteAvatarsCreatedOnAug8;

    async function deleteAvatarsWithBlankNames() {
      const avatarRef = collection(db, "galleryCharacters");
      const q = query(avatarRef, where("name", "==", ""));

      try {
        const snapshot = await getDocs(q);
        console.log(`Found ${snapshot.size} avatars with blank names.`);

        for (const docSnap of snapshot.docs) {
          await deleteDoc(docSnap.ref);
          console.log(`üóëÔ∏è Deleted: ${docSnap.id}`);
        }
      } catch (err) {
        console.error("‚ùå Error deleting avatars:", err);
      }
    }

    // expose so you can call it from the console
    window.deleteAvatarsWithBlankNames = deleteAvatarsWithBlankNames;

    async function deleteAvatarsWithNoFavThing() {
      const avatarRef = collection(db, "galleryCharacters");
      const q = query(avatarRef, where("favThing", "==", ""));

      try {
        const snapshot = await getDocs(q);
        console.log(`Found ${snapshot.size} avatars with no favThing.`);

        for (const docSnap of snapshot.docs) {
          await deleteDoc(docSnap.ref);
          console.log(`üóëÔ∏è Deleted: ${docSnap.id}`);
        }
      } catch (err) {
        console.error("‚ùå Error deleting avatars:", err);
      }
    }

    // make available in console
    window.deleteAvatarsWithNoFavThing = deleteAvatarsWithNoFavThing;

    async function deleteAvatarsByName(nameToDelete) {
      if (!nameToDelete || typeof nameToDelete !== "string") {
        console.error("‚ùå Please provide a valid name string");
        return;
      }

      const avatarRef = collection(db, "galleryCharacters");
      const q = query(avatarRef, where("name", "==", nameToDelete));

      try {
        const snapshot = await getDocs(q);
        console.log(`Found ${snapshot.size} avatars with name: "${nameToDelete}"`);

        for (const docSnap of snapshot.docs) {
          await deleteDoc(docSnap.ref);
          console.log(`üóëÔ∏è Deleted: ${docSnap.id}`);
        }
      } catch (err) {
        console.error("‚ùå Error deleting avatars:", err);
      }
    }

    // Expose it globally so you can run from console
    window.deleteAvatarsByName = deleteAvatarsByName;


    async function countAllAvatars() {
      const avatarRef = collection(db, "galleryCharacters");

      try {
        const snapshot = await getDocs(avatarRef);
        console.log(`üìä Total avatars: ${snapshot.size}`);
        return snapshot.size;
      } catch (err) {
        console.error("‚ùå Error counting avatars:", err);
        return 0;
      }
    }

    // expose globally so you can call from console
    window.countAllAvatars = countAllAvatars;



  </script>




</body>

<script>




  // start empty; we'll fill these from CSV
  let hairHatTraits = {};
  let torsoTraits = {};
  let legsTraits = {};
  let shoesTraits = {};

  // tiny CSV ‚Üí map(filename ‚Üí trait). assumes headers: filename,trait
  function csvToMap(text) {
    const lines = text.trim().split(/\r?\n/);
    // find header indexes in case order changes
    const header = lines.shift().split(',');
    const fi = header.findIndex(h => /filename/i.test(h));
    const ti = header.findIndex(h => /trait/i.test(h));
    const map = {};
    for (const line of lines) {
      if (!line.trim()) continue;
      // simple split is fine because no quoted commas in your data
      const cols = line.split(',');
      const file = cols[fi]?.trim();
      const trait = cols[ti]?.trim();
      if (file && trait) map[file] = trait;
    }
    return map;
  }

  // load all four csvs in parallel
  async function loadAllTraits() {
    const paths = {
      hairHatTraits: './assets/traits/hair-hat.csv',
      torsoTraits: './assets/traits/torso.csv',
      legsTraits: './assets/traits/legs.csv',
      shoesTraits: './assets/traits/shoes.csv'
    };

    const [hairCSV, torsoCSV, legsCSV, shoesCSV] = await Promise.all([
      fetch(paths.hairHatTraits).then(r => r.text()),
      fetch(paths.torsoTraits).then(r => r.text()),
      fetch(paths.legsTraits).then(r => r.text()),
      fetch(paths.shoesTraits).then(r => r.text()),
    ]);

    hairHatTraits = csvToMap(hairCSV);
    torsoTraits = csvToMap(torsoCSV);
    legsTraits = csvToMap(legsCSV);
    shoesTraits = csvToMap(shoesCSV);
  }

  // call before UI needs traits
  // if you already have other DOMContentLoaded work, just await this first
  document.addEventListener('DOMContentLoaded', async () => {
    try {
      await loadAllTraits();
      await loadKeywordIndex();

      // optional: update trait cards immediately if items already selected
      if (typeof updateTraitCards === 'function') updateTraitCards();
    } catch (e) {
      console.error('failed to load trait csvs', e);
    }
  });

  // helper: hide duplicates but keep first occurrence
  function dedupeList(list) {
    const seen = new Set();
    return list.map(t => {
      const v = (t || '').trim();
      if (!v || seen.has(v)) return '';   // blank out dups
      seen.add(v);
      return v;
    });
  }

  // helper: for [{text,color}, ...]
  function dedupeEntries(entries) {
    const seen = new Set();
    return entries.map(e => {
      const v = (e.text || '').trim();
      if (!v || seen.has(v)) return { ...e, text: '' };
      seen.add(v);
      return e;
    });
  }

  // keyword -> index (lowercase keys)
  let keywordIndexMap = {};

  function csvToKeywordIndex(text) {
    const lines = text.trim().split(/\r?\n/);
    const header = lines.shift().split(',');
    const ki = header.findIndex(h => /keyword/i.test(h));
    const ii = header.findIndex(h => /(image\s*number|number|index)/i.test(h));
    const map = {};
    for (const line of lines) {
      if (!line.trim()) continue;
      const cols = line.split(',');
      const kw = (cols[ki] || '').trim().toLowerCase();
      const num = parseInt((cols[ii] || '').trim(), 10);
      if (kw && Number.isFinite(num)) map[kw] = num;
    }
    return map;
  }

  async function loadKeywordIndex() {
    const csv = await fetch('./assets/traits/pdd_keywords.csv').then(r => r.text());
    keywordIndexMap = csvToKeywordIndex(csv);
  }

  // cache loaded badge images: number -> HTMLImageElement
  const badgeCache = new Map();

  function badgeUrlFromTrait(trait) {
    const idx = keywordIndexMap[(trait || '').trim().toLowerCase()];
    if (!idx) return null;
    return `./assets/traits/badges/${idx}.svg`;
  }

  function loadBadgeImage(url) {
    if (!url) return Promise.resolve(null);
    // use cache key = url (or extracted number)
    const key = url;
    if (badgeCache.has(key)) return Promise.resolve(badgeCache.get(key));

    return new Promise(resolve => {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => { badgeCache.set(key, img); resolve(img); };
      img.onerror = () => resolve(null);
      img.src = url;
    });
  }
</script>

<script>



  document.querySelector('.tc-close').addEventListener('click', () => {
    document.getElementById('tc-modal').style.display = 'none';
  });

  const root = document.body;
  const canvasEl = document.getElementById('faceCanvas');
  const toolbarEl = document.querySelector('.draw-toolbar');

  // hide them until stage-3
  canvasEl.style.display = 'none';
  toolbarEl.style.display = 'none';



  function goBack() {
    window.location.href = "./index.html";
  }

  // === CONFIG ===

  const baseRig = {
    head: { x: 0, y: 0 },
    neck: { x: 0, y: 30 },
    shoulderL: { x: -40, y: 40 },
    shoulderR: { x: 40, y: 40 },
    elbowL: { x: -70, y: 100 },
    elbowR: { x: 70, y: 100 },
    handL: { x: -80, y: 160 },
    handR: { x: 80, y: 160 },
    hipL: { x: -20, y: 170 },
    hipR: { x: 20, y: 170 },
    kneeL: { x: -30, y: 260 },
    kneeR: { x: 30, y: 260 },
    footL: { x: -40, y: 330 },
    footR: { x: 40, y: 330 }
  };

  const bones = [
    ['head', 'neck'],
    ['neck', 'shoulderL'],
    ['neck', 'shoulderR'],
    ['shoulderL', 'elbowL'],
    ['shoulderR', 'elbowR'],
    ['elbowL', 'handL'],
    ['elbowR', 'handR'],
    ['neck', 'hipL'],
    ['neck', 'hipR'],
    ['hipL', 'kneeL'],
    ['hipR', 'kneeR'],
    ['kneeL', 'footL'],
    ['kneeR', 'footR']
  ];





  const svg = document.getElementById('rig');
  const svgWidth = svg.viewBox.baseVal.width;
  const svgHeight = svg.viewBox.baseVal.height;

  let scale;
  let yspacing = 70;
  window.addEventListener('resize', setScaleForViewport);
  window.addEventListener('resize', () => {
    if (document.body.classList.contains('stage-3')) {
      resizeCanvasToFace();
      layoutSwatchesInArc();
      placeUndoNearSwatches(); // <‚Äî add
    }
  });



  function svgPointToClient(x, y) {
    const pt = svg.createSVGPoint()
    pt.x = x; pt.y = y
    const screenPt = pt.matrixTransform(svg.getScreenCTM())
    return { x: screenPt.x, y: screenPt.y }
  }


  function setScaleForViewport() {
    if (window.innerWidth <= 768) {
      scale = 1.9;
      console.log("check mobile")
    } else {
      scale = 1.3;
    }

    // updateNodes();
  }

  setScaleForViewport();


  let origin = { x: svgWidth / 2, y: 100 };

  // Live nodes
  const nodes = {};
  updateNodes();

  // Create bones & joints
  const lines = [];
  const circles = [];

  bones.forEach(([a, b]) => {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('stroke', 'red');
    line.setAttribute('stroke-width', 3);
    //svg.appendChild(line);
    lines.push({ line, a, b });
  });

  Object.keys(nodes).forEach(name => {
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('r', 8);
    circle.setAttribute('fill', 'red');
    circle.style.cursor = 'pointer';
    //svg.appendChild(circle);
    circles.push({ circle, name });
  });

  // Store original bone lengths:
  const boneLengths = {};
  bones.forEach(([a, b]) => {
    const dx = nodes[a].x - nodes[b].x;
    const dy = nodes[a].y - nodes[b].y;
    boneLengths[`${a}-${b}`] = Math.hypot(dx, dy);
    boneLengths[`${b}-${a}`] = boneLengths[`${a}-${b}`]; // symmetric
  });


  // CAROUSEL



  // === DRAGGING ===

  let dragging = null;

  circles.forEach(({ circle, name }) => {
    circle.addEventListener('mousedown', e => startDrag(e, name));
    circle.addEventListener('touchstart', e => startDrag(e, name));
  });

  window.addEventListener('mousemove', dragMove);
  window.addEventListener('touchmove', dragMove, { passive: false });

  window.addEventListener('mouseup', endDrag);
  window.addEventListener('touchend', endDrag);

  function startDrag(e, name) {
    e.preventDefault();
    dragging = name;
  }

  function dragMove(e) {
    if (!dragging) return;
    e.preventDefault();

    const pt = getMousePos(e);

    // Find its connected neighbors
    const connected = bones.filter(([a, b]) => a === dragging || b === dragging)
      .map(([a, b]) => (a === dragging ? b : a));

    // For simplicity, we constrain to just the FIRST neighbor:
    if (connected.length) {
      const parent = connected[0];
      const length = boneLengths[`${dragging}-${parent}`];

      const dx = pt.x - nodes[parent].x;
      const dy = pt.y - nodes[parent].y;
      const dist = Math.hypot(dx, dy) || 1;

      const newX = nodes[parent].x + dx / dist * length;
      const newY = nodes[parent].y + dy / dist * length;

      nodes[dragging].x = newX;
      nodes[dragging].y = newY;
    } else {
      // If no connected parent, allow free drag (e.g. head)
      nodes[dragging].x = pt.x;
      nodes[dragging].y = pt.y;
    }
  }



  function endDrag() {
    dragging = null;
  }

  function getMousePos(e) {
    let clientX, clientY;
    if (e.touches && e.touches.length) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }

    const rect = svg.getBoundingClientRect();
    return {
      x: ((clientX - rect.left) / rect.width) * svg.viewBox.baseVal.width,
      y: ((clientY - rect.top) / rect.height) * svg.viewBox.baseVal.height
    };
  }

  // === UPDATE LOOP ===

  function animate() {
    lines.forEach(({ line, a, b }) => {
      line.setAttribute('x1', nodes[a].x);
      line.setAttribute('y1', nodes[a].y);
      line.setAttribute('x2', nodes[b].x);
      line.setAttribute('y2', nodes[b].y);
    });

    circles.forEach(({ circle, name }) => {
      circle.setAttribute('cx', nodes[name].x);
      circle.setAttribute('cy', nodes[name].y);
    });

    if (!root.classList.contains('stage-4')) {
      // positionCarousels();
    }

    requestAnimationFrame(animate);

  }
  animate();

  // === INIT ===



  function updateNodes() {
    Object.entries(baseRig).forEach(([name, pos]) => {
      if (window.innerWidth <= 768)
        yspacing = 0;
      else
        yspacing = 100;

      nodes[name] = {
        x: origin.x + pos.x * scale,
        y: origin.y + yspacing + pos.y * scale
      };
    });
  }

  function loadInlineSVG(src, targetEl) {
    // clear old content and show spinner
    targetEl.innerHTML = '';
    const spinner = document.createElement('div');
    spinner.classList.add('spinner');
    targetEl.appendChild(spinner);

    fetch(src)
      .then(res => res.text())
      .then(svgText => {
        // replace spinner with svg
        targetEl.innerHTML = svgText;
        // optional: turn white fills to black
        targetEl.querySelectorAll('[fill="#fff"], [fill="#ffffff"], [fill="white"]')
          .forEach(el => el.setAttribute('fill', 'black'));
      })
      .catch(err => {
        console.error('failed to load SVG:', src, err);
        // remove spinner on error
        spinner.remove();
      });
  }



  class Carousel {
    constructor({ listEl, swipeEl, images, category, spacing = 320, prevBtnColor = 'blue-bg', nextBtnColor = 'blue-bg', btnSize = 'extrasmall' }) {
      this.listEl = listEl;
      this.swipeEl = swipeEl;
      this.images = images;
      this.currentIndex = 0;
      this.category = category;
      this.spacing = window.innerWidth <= 768 ? 150 : spacing;
      this.prevBtnColor = prevBtnColor;
      this.nextBtnColor = nextBtnColor;
      this.btnSize = btnSize;

      this.init();
    }

    init() {
      this.buildSlides()
      this.bindEvents()
      this.createNavButtons()
      this.updateClasses()         // first pass
      setTimeout(() => {
        this.updateClasses()       // second pass after svg fetch/layout
      }, 10)                       // you can lower this delay if it's too long
    }

    buildSlides() {
      this.listEl.innerHTML = '';
      this.images.forEach(src => {
        const li = document.createElement('li');
        const svgContainer = document.createElement('div');
        svgContainer.classList.add('svg-container');
        svgContainer.style.width = '100%';
        svgContainer.style.height = '100%';
        loadInlineSVG(src, svgContainer);
        li.appendChild(svgContainer);
        this.listEl.appendChild(li);
      });
    }

    updateClasses() {
      const items = Array.from(this.listEl.children);
      const len = items.length;
      items.forEach((li, i) => {
        li.className = '';
        const offset = (i - this.currentIndex + len) % len;
        if (offset === 0) li.classList.add('act');
        else if (offset === 1) li.classList.add('next');
        else if (offset === 2) li.classList.add('new-next');
        else if (offset === len - 1) li.classList.add('prev');
        else if (offset === len - 2) li.classList.add('hide');
      });

      // Defer repositioning so DOM updates complete
      requestAnimationFrame(() => this.positionNavButtons());
    }



    next() {
      this.currentIndex = (this.currentIndex + 1) % this.images.length;
      this.updateClasses();
    }

    prev() {
      this.currentIndex = (this.currentIndex - 1 + this.images.length) % this.images.length;
      this.updateClasses();
    }

    bindEvents() {
      this.listEl.addEventListener('click', e => {
        const li = e.target.closest('li');
        if (!li) return;
        if (li.classList.contains('next')) this.next();
        else if (li.classList.contains('prev')) this.prev();
      });

      const hammer = new Hammer(this.swipeEl);
      hammer.on('swipeleft', () => this.next());
      hammer.on('swiperight', () => this.prev());
    }

    createNavButtons() {
      this.prevBtn = document.createElement('button');
      this.nextBtn = document.createElement('button');

      this.prevBtn.classList.add('circle-button', this.btnSize, this.prevBtnColor, 'carousel-nav');
      this.nextBtn.classList.add('circle-button', this.btnSize, this.nextBtnColor, 'carousel-nav');

      this.prevBtn.innerText = '‚Üê';
      this.nextBtn.innerText = '‚Üí';

      this.prevBtn.addEventListener('click', () => this.prev());
      this.nextBtn.addEventListener('click', () => this.next());

      document.body.appendChild(this.prevBtn);
      document.body.appendChild(this.nextBtn);
    }

    positionNavButtons() {
      const rect = this.listEl.getBoundingClientRect();
      const btnW = this.prevBtn.offsetWidth;
      const btnH = this.prevBtn.offsetHeight;

      Object.assign(this.prevBtn.style, {
        position: 'absolute',
        left: `${rect.left - this.spacing}px`,
        top: `${rect.top + (rect.height - btnH) / 2}px`,
        zIndex: '10'
      });

      Object.assign(this.nextBtn.style, {
        position: 'absolute',
        left: `${rect.right + this.spacing - btnW}px`,
        top: `${rect.top + (rect.height - btnH) / 2}px`,
        zIndex: '10'
      });
    }
  }

  // example usage:


  const hats = [
    './assets/char/hair-hat/hair-hat-01.svg',
    './assets/char/hair-hat/hair-hat-02.svg',
    './assets/char/hair-hat/hair-hat-03.svg',
    './assets/char/hair-hat/hair-hat-04.svg',
    './assets/char/hair-hat/hair-hat-05.svg'
  ];
  const torsos = [
    './assets/char/torso/torso-01.svg',
    './assets/char/torso/torso-02.svg',
    './assets/char/torso/torso-03.svg',
    './assets/char/torso/torso-04.svg',
    './assets/char/torso/torso-05.svg'

  ];
  const legs = [
    './assets/char/legs/legs-01.svg',
    './assets/char/legs/legs-02.svg',
    './assets/char/legs/legs-03.svg',
    './assets/char/legs/legs-04.svg',
    './assets/char/legs/legs-05.svg'
  ];
  const shoes = [
    './assets/char/shoes/shoes-01.svg',
    './assets/char/shoes/shoes-02.svg',
    './assets/char/shoes/shoes-03.svg',
    './assets/char/shoes/shoes-04.svg',
    './assets/char/shoes/shoes-05.svg'
  ];

  // 2. build imageSets with those named arrays
  const imageSets = [hats, torsos, legs, shoes];

  // document.querySelectorAll('.list').forEach((listEl, i) => {
  //   const swipeEl = document.querySelectorAll('.swipe')[i]
  //   new Carousel({ listEl, swipeEl, images: imageSets[i] })
  // })

  function positionCarousels() {

    // if (stage === 4) return;

    // head node
    const headPos = svgPointToClient(nodes.head.x, nodes.head.y)
    const headDiv = document.querySelector('.head')
    headDiv.style.left = `${headPos.x}px`

    if (window.innerWidth <= 768)
      headDiv.style.top = `${headPos.y - (yspacing + 250)}px`
    else
      headDiv.style.top = `${headPos.y - (yspacing + 100)}px`



    // torso center = average of shoulderL, shoulderR, hipR, hipL
    const keys = ['shoulderL', 'shoulderR', 'hipR', 'hipL']
    const sum = keys.reduce((acc, k) => {
      acc.x += nodes[k].x
      acc.y += nodes[k].y
      return acc
    }, { x: 0, y: 0 })
    const avg = { x: sum.x / 4, y: sum.y / 4 }
    const torsoPos = svgPointToClient(avg.x, avg.y)
    const torsoDiv = document.querySelector('.torso')
    torsoDiv.style.left = `${torsoPos.x}px`

    if (window.innerWidth <= 768)
      torsoDiv.style.top = `${torsoPos.y - (yspacing + 260)}px`
    else
      torsoDiv.style.top = `${torsoPos.y - (yspacing + 150)}px`

    //leg 
    const kneeLClient = svgPointToClient(nodes.kneeL.x, nodes.kneeL.y);
    const kneeRClient = svgPointToClient(nodes.kneeR.x, nodes.kneeR.y);
    const kneeAvgX = (kneeLClient.x + kneeRClient.x) / 2;
    const kneeAvgY = (kneeLClient.y + kneeRClient.y) / 2;
    const legsDiv = document.querySelector('.legs');
    legsDiv.style.left = `${kneeAvgX}px`;
    // adjust the vertical offset as needed; using same ‚àí250 for now
    legsDiv.style.top = `${kneeAvgY + 0}px`;


  }








  // collect your carousels
  const carousels = [];
  const categories = ['hair-hat', 'torso', 'legs', 'shoes'];

  document.querySelectorAll('.list').forEach((listEl, i) => {
    const swipeEl = document.querySelectorAll('.swipe')[i];
    const carousel = new Carousel({
      listEl,
      swipeEl,
      images: imageSets[i],
      category: categories[i]
    });
    // keep a copy of the non-patterned set
    carousel.originalImages = [...carousel.images];
    carousels.push(carousel);
  });

  let stage = 1;
  const footer = document.querySelector('.footer-section');
  const backBtn = document.querySelector('.back-btn');
  const nextBtn = document.querySelector('.next-btn');
  const titleEl = document.querySelector('.title-section h1');
  const subtitleEl = document.querySelector('.subtitle');
  const originalSubtitle = subtitleEl.textContent.trim();
  const stepEls = Array.from(document.querySelectorAll('.steps .step'));


  footer.classList.add('stage-1');

  // helper: swap all carousels into their patterned variants
  function applyPatterned(carousels) {
    carousels.forEach(carousel => {
      // save user‚Äôs outline choice
      carousel.originalIndex = carousel.currentIndex;

      // figure out which pattern folder to load
      const activeSrc = carousel.images[carousel.currentIndex];
      const baseName = activeSrc.match(/\/([^\/]+)\.svg$/)[1]; // e.g. "torso-02"
      const idx = baseName.split('-').pop();              // "02"

      // build the patterned paths
      const patterned = Array.from({ length: 5 }, (_, i) => {
        const kk = String(i + 1).padStart(2, '0');
        return `./assets/patterned/${carousel.category}/${idx}/${baseName}-${kk}.svg`;
      });

      // animate the swap, then reset to pattern #1
      animateCarouselSwap(carousel, patterned, () => {
        carousel.currentIndex = 0;
      });
    });
  }


  // helper: restore each carousel‚Äôs original images + selection
  function restoreOriginals(carousels) {
    carousels.forEach(carousel => {
      const originals = [...carousel.originalImages];

      // animate back to the originals, then restore the chosen index
      animateCarouselSwap(carousel, originals, () => {
        carousel.currentIndex = carousel.originalIndex;
      });
    });
  }

  function setStep(activeIndex) {
    stepEls.forEach((el, i) => {
      el.classList.toggle('active', i === activeIndex);
    });
  }

  function updateTitleSection(stage) {
    const titleSection = document.querySelector('.title-section');
    const h1 = titleSection.querySelector('h1');
    const subtitle = titleSection.querySelector('.subtitle');
    const steps = Array.from(titleSection.querySelectorAll('.step'));

    // update step active state
    steps.forEach((el, i) => {
      el.classList.toggle('active', i === stage - 1);
    });

    // update text content
    if (stage === 1) {
      h1.textContent = "CHOOSE YOUR CHARACTER'S BASIC OUTFIT.";
      subtitle.textContent = "Use the left and right arrows for each section to choose.";
    } else if (stage === 2) {
      h1.textContent = "LET'S ADD SOME FUN PRINTS AND PATTERNS!";
      subtitle.textContent = "Use the left and right arrows for each section to choose.";
    } else if (stage === 3) {
      h1.textContent = "GIVE YOUR CHARACTER A FACE!";
      subtitle.textContent = "Click and drag over the face. You can add eyes, a nose, a mouth or whatever else you please.";
    } else if (stage === 4) {
      h1.textContent = "LET'S ADD A FEW MORE DETAILS!";
      subtitle.textContent = "Tell us your character's name, and their favourite thing to do in Punggol.";
    }
  }

  function updateTraitCards() {
    const selections = carousels.map(c => c.images[c.currentIndex]);
    const hatFile = selections[0].split('/').pop();
    const torsoFile = selections[1].split('/').pop();
    const legsFile = selections[2].split('/').pop();
    const shoesFile = selections[3].split('/').pop();

    const raw = [
      hairHatTraits[hatFile] || '',
      torsoTraits[torsoFile] || '',
      legsTraits[legsFile] || '',
      shoesTraits[shoesFile] || ''
    ];

    // dedupe while keeping first seen
    const seen = new Set();
    const unique = raw.filter(t => {
      const v = (t || '').trim();
      if (!v || seen.has(v)) return false;
      seen.add(v);
      return true;
    });

    const list = document.querySelector('.traits-card .traits-list');
    list.innerHTML = '';

    unique.forEach(trait => {
      const url = badgeUrlFromTrait(trait);
      if (!url) return;

      const img = document.createElement('img');
      img.alt = trait;
      img.src = url;
      img.width = 96;
      img.height = 96;

      // random tilt between -20¬∞ and +20¬∞
      const tilt = (Math.random() * 40) - 20;

      // random offset: shift up/down & left/right a bit (in px)
      const offsetX = (Math.random() * 16) - 8;  // -8px ‚Üí +8px
      const offsetY = (Math.random() * 16) - 8;  // -8px ‚Üí +8px

      img.style.transform = `rotate(${tilt}deg) translate(${offsetX}px, ${offsetY}px)`;

      list.appendChild(img);
    });


  }



  // Arc layout for color swatches
  function layoutSwatchesInArc() {
    const swatches = document.querySelectorAll('.color-picker .color-swatch');
    const radius = 200;
    const arcStart = 90 + 45 + 10;     // start angle in degrees
    const arcEnd = 270 - 45 - 10;    // end angle in degrees
    const step = (arcEnd - arcStart) / (swatches.length - 1);

    // detect mobile
    const isMobile = window.innerWidth <= 768;
    const rotationOffset = isMobile ? 90 : 0;  // add 90¬∞ on mobile

    swatches.forEach((swatch, i) => {
      // compute base angle then add offset
      const angleDeg = arcStart + step * i + rotationOffset;
      const angle = angleDeg * Math.PI / 180;

      // you can leave your centers the same
      const x = radius * Math.cos(angle) + 275;
      const y = radius * Math.sin(angle) + 60;

      swatch.style.left = `${x}px`;
      swatch.style.top = `${y}px`;
    });
  }

  // don't forget to re‚Äërun on resize if your layout can change:
  window.addEventListener('resize', () => {
    layoutSwatchesInArc();
  });


  function layoutButtonsInArc() {
    const buttons = document.querySelectorAll('.button-row .arc-button');
    const radius = 200;
    const arcStart = 90 - 45 - 25;    // start angle in degrees
    const arcEnd = -90 + 45 + 25;    // end angle in degrees
    const step = (arcEnd - arcStart) / (buttons.length - 1);

    // detect mobile
    const isMobile = window.innerWidth <= 768;
    const rotationOffset = isMobile ? 90 : 0;  // add 90¬∞ on mobile only

    buttons.forEach((btn, i) => {
      // compute the base angle + offset
      const angleDeg = arcStart + step * i + rotationOffset;
      const angle = angleDeg * Math.PI / 180;

      // lay out as before
      const x = radius * Math.cos(angle) + 275;  // adjust centerX if needed
      const y = radius * Math.sin(angle) + 60;  // adjust centerY if needed

      btn.style.left = `${x}px`;
      btn.style.top = `${y}px`;
    });
  }

  function placeToolbarNearHead() {
    const tb = document.querySelector('.draw-toolbar');
    if (!tb) return;

    // only do special placement on mobile (<=768px)
    const isMobile = window.innerWidth <= 768;
    if (!isMobile || !document.body.classList.contains('stage-3')) {
      return;
    }

    // anchor to the active head SVG box
    const headBox = document.querySelector('.head .list li.act .svg-container');
    if (!headBox) return;

    const rect = headBox.getBoundingClientRect();
    // ensure toolbar has its natural size before measuring
    tb.style.position = 'fixed';
    tb.style.transform = 'none';
    tb.style.left = '0px';
    tb.style.top = '0px';

    // measure after it's fixed so offsetWidth/Height are correct
    const pad = 12;
    const vw = window.innerWidth;
    const tbW = tb.offsetWidth;
    const tbH = tb.offsetHeight;

    // try to place ABOVE the head; if not enough room, place BELOW
    let top = rect.top - tbH - pad;
    if (top < pad) top = Math.min(window.innerHeight - tbH - pad, rect.bottom + pad);

    // center horizontally over the head, clamped to screen
    let left = rect.left + rect.width / 2 - tbW / 2;
    left = Math.max(pad, Math.min(left, vw - tbW - pad));

    tb.style.top = `${Math.round(top)}px`;
    tb.style.left = `${Math.round(left)}px`;
  }

  function placeUndoNearSwatches() {
    // only in stage-3 on mobile
    if (window.innerWidth <= 768 && document.body.classList.contains('stage-3')) {
      const undo = document.getElementById('undoBtn');
      const lastSwatch = document.querySelector('.color-picker .color-swatch:last-child');
      if (!undo || !lastSwatch) return;

      undo.style.left = '0px';
      undo.style.top = '0px';

      const sw = lastSwatch.getBoundingClientRect();
      const undoW = undo.offsetWidth;
      const undoH = undo.offsetHeight;

      const gap = 12;
      let left = sw.right + gap;
      let top = sw.top + (sw.height - undoH) / 2;

      const maxLeft = window.innerWidth - undoW - 8;
      const maxTop = window.innerHeight - undoH - 8;
      left = Math.max(8, Math.min(left, maxLeft));
      top = Math.max(8, Math.min(top, maxTop));

      undo.style.left = `${Math.round(left)}px`;
      undo.style.top = `${Math.round(top)}px`;
    }
  }

  function placeToolbarNearHeadAndLayout() {
    placeToolbarNearHead();
    layoutSwatchesInArc();

    layoutButtonsInArc();
    placeUndoNearSwatches();  // <‚Äî add this
  }


  // rerun on resize to keep things in sync
  window.addEventListener('resize', layoutButtonsInArc);
  window.addEventListener('DOMContentLoaded', layoutButtonsInArc);


  document.addEventListener('DOMContentLoaded', () => {
    layoutSwatchesInArc();
    layoutButtonsInArc();
  });







  /**
   * fades out, swaps images, runs callback (e.g. set index), then fades back in
   *
   * @param {Carousel} carousel
   * @param {string[]} newImages
   * @param {Function} onSwapComplete ‚Äî called after images have been swapped but before fade-in
   */
  function animateCarouselSwap(carousel, newImages, onSwapComplete) {
    const listEl = carousel.listEl;

    // 1) kick off the fade-out
    listEl.classList.add('is-animating');

    setTimeout(() => {
      // 2) swap your data & set whatever index you need
      carousel.images = newImages;
      if (onSwapComplete) onSwapComplete();

      // rebuild all the <li>/.svg-container DOM
      carousel.buildSlides();
      carousel.updateClasses();

      // 3) wait until the next frame so the browser has
      //    actually applied `opacity: 0` to the new containers
      requestAnimationFrame(() => {
        // now remove the class ‚Üí transitions back to opacity:1
        listEl.classList.remove('is-animating');
      });
    }, 300);  // matches your 0.3s CSS fade-out
  }


  let _stage4ScrollHandler = null;

  function enableSubmitOnlyAtBottom() {
    if (window.innerWidth > 768) return; // mobile only

    const scroller = document.querySelector('.builder-section');
    if (!scroller) return;

    // Hide footer until bottom
    document.body.classList.remove('show-submit');

    const onScroll = () => {
      const atBottom = scroller.scrollTop + scroller.clientHeight >= scroller.scrollHeight - 10;
      document.body.classList.toggle('show-submit', atBottom);
    };

    // Save so we can remove later
    _stage4ScrollHandler = onScroll;

    // Bind + run once
    scroller.addEventListener('scroll', onScroll, { passive: true });
    // In case it already fits on screen (short content)
    requestAnimationFrame(onScroll);
  }

  function disableSubmitOnlyAtBottom() {
    const scroller = document.querySelector('.builder-section');
    if (scroller && _stage4ScrollHandler) {
      scroller.removeEventListener('scroll', _stage4ScrollHandler);
    }
    _stage4ScrollHandler = null;
    document.body.classList.remove('show-submit');
  }





  // 1. grab canvas & ctx
  const canvas = document.getElementById('faceCanvas');
  const ctx = canvas.getContext('2d');

  // 2. resize helper
  function resizeCanvasToFace() {
    const container = document.querySelector('.head .list li.act .svg-container');
    if (!container) return;

    const box = container.getBoundingClientRect();
    const newW = box.width, newH = box.height;

    // Some mobile browsers (Android Chrome) report zero when the carousel
    // has just been hidden; skip resizing to avoid nuking the strokes.
    if (newW < 2 || newH < 2) {
      return;
    }
    const oldW = canvasEl.width, oldH = canvasEl.height;

    if (oldW && oldH) {
      const xScale = newW / oldW;
      const yScale = newH / oldH;
      const avgScale = (xScale + yScale) / 2;

      [strokes, redoStack].forEach(stack => {
        stack.forEach(stroke => {
          stroke.points.forEach(pt => {
            pt.x *= xScale;
            pt.y *= yScale;
          });
          stroke.width *= avgScale;
        });
      });
    }

    const manualYAdjust = -25;
    canvasEl.width = newW;
    canvasEl.height = newH;
    Object.assign(canvasEl.style, {
      position: 'fixed',
      left: `${box.left}px`,
      top: `${box.top + manualYAdjust}px`,
      width: `${newW}px`,
      height: `${newH}px`
    });

    drawAllStrokes();
  }





  window.addEventListener('resize', () => {
    if (root.classList.contains('stage-3')) resizeCanvasToFace();
  });


  window.addEventListener('resize', resizeCanvasToFace);

  // 3. strokes data
  const strokes = [];
  const redoStack = []; // for redo
  let currentStroke = null;
  let brushColor = '#000';
  const brushSize = 10;

  // 4. draw all saved strokes
  function drawAllStrokes() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    strokes.forEach(stroke => {
      drawSmoothStroke(stroke);
    });
  }

  function drawSmoothStroke(stroke) {
    if (stroke.points.length < 3) {
      // just draw a straight line for very short strokes, then return
      const pts = stroke.points
      if (pts.length === 2) {
        ctx.beginPath()
        ctx.moveTo(pts[0].x, pts[0].y)
        ctx.lineTo(pts[1].x, pts[1].y)
        ctx.strokeStyle = stroke.color
        ctx.lineWidth = stroke.width
        ctx.stroke()
      }
      return
    }
    ctx.beginPath();
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = stroke.color;
    ctx.lineWidth = stroke.width;

    const pts = stroke.points;
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length - 2; i++) {
      const xc = (pts[i].x + pts[i + 1].x) / 2;
      const yc = (pts[i].y + pts[i + 1].y) / 2;
      ctx.quadraticCurveTo(pts[i].x, pts[i].y, xc, yc);
    }
    // curve through the last two points
    const n = pts.length;
    ctx.quadraticCurveTo(
      pts[n - 2].x, pts[n - 2].y,
      pts[n - 1].x, pts[n - 1].y
    );
    ctx.stroke();
  }


  // 5. pointer events on canvas
  canvas.addEventListener('pointerdown', e => {
    redoStack.length = 0;                 // ‚üµ clear redo history
    currentStroke = { color: brushColor, width: brushSize, points: [] };
    const x = e.offsetX, y = e.offsetY;
    currentStroke.points.push({ x, y });
    ctx.beginPath();
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.lineWidth = brushSize;
    ctx.strokeStyle = brushColor;
    ctx.moveTo(x, y);
    canvasEl.setPointerCapture(e.pointerId);
  });

  // canvas.addEventListener('pointermove', e => {
  //   if (!currentStroke) return;
  //   const x = e.offsetX, y = e.offsetY;
  //   currentStroke.points.push({ x, y });
  //   ctx.lineTo(x,y);
  //   ctx.stroke();
  // });

  canvas.addEventListener('pointerup', e => {
    if (!currentStroke) return;
    canvas.releasePointerCapture(e.pointerId);
    strokes.push(currentStroke);
    currentStroke = null;
  });

  // 6. undo & clear
  document.getElementById('undoBtn').onclick = () => {
    if (strokes.length) {
      redoStack.push(strokes.pop());   // move last stroke to redo
      drawAllStrokes();
    }
  };

  const redoBtn = document.getElementById('redoBtn');
  redoBtn.onclick = () => {
    if (redoStack.length) {
      strokes.push(redoStack.pop());   // bring it back
      drawAllStrokes();
    }
  };


  document.getElementById('clearBtn').onclick = () => {
    strokes.length = 0;
    redoStack.length = 0;
    drawAllStrokes();
  };


  let lastMidpoint = null;

  canvasEl.addEventListener('pointermove', e => {
    if (!currentStroke) return;
    const x = e.offsetX, y = e.offsetY;
    currentStroke.points.push({ x, y });

    if (currentStroke.points.length > 2) {
      const len = currentStroke.points.length;
      const p1 = currentStroke.points[len - 3];
      const p2 = currentStroke.points[len - 2];
      const midX = (p1.x + p2.x) / 2;
      const midY = (p1.y + p2.y) / 2;

      if (lastMidpoint) {
        ctx.beginPath();
        ctx.moveTo(lastMidpoint.x, lastMidpoint.y);
        ctx.quadraticCurveTo(p1.x, p1.y, midX, midY);
        ctx.stroke();
      }
      lastMidpoint = { x: midX, y: midY };
    }
  });
  canvasEl.addEventListener('pointerup', () => {
    lastMidpoint = null;
  });




  // grab all swatches
  const swatches = document.querySelectorAll('.color-swatch')
  // set initial selected
  swatches[0].classList.add('selected')
  brushColor = swatches[0].dataset.color

  swatches.forEach(s => {
    s.addEventListener('click', () => {
      // clear old selection
      swatches.forEach(x => x.classList.remove('selected'))
      // mark new
      s.classList.add('selected')
      // update brushColor
      brushColor = s.dataset.color
    })
  })

  // call this instead of relying on .head/.torso divs
  function drawFinalRig() {
    const svgNS = "http://www.w3.org/2000/svg";

    // hide carousel UI
    ['head', 'torso', 'legs', 'shoes'].forEach(cat => {
      const el = document.querySelector(`.${cat}`);
      if (el) el.style.display = 'none';
    });
    document.querySelectorAll('.carousel-nav').forEach(btn => {
      btn.style.display = 'none';
    });

    // clear previous final images & base shape
    svg.querySelectorAll('image.final-img, g.base-shape').forEach(el => el.remove());

    // get the four printed SVG URLs
    const selections = carousels.map(c => c.images[c.currentIndex]);

    // compute joint centers
    const headCtr = nodes.head;
    const torsoCtr = {
      x: (nodes.shoulderL.x + nodes.shoulderR.x + nodes.hipL.x + nodes.hipR.x) / 4,
      y: (nodes.shoulderL.y + nodes.shoulderR.y + nodes.hipL.y + nodes.hipR.y) / 4 + 10
    };
    const legsCtr = {
      x: (nodes.kneeL.x + nodes.kneeR.x) / 2,
      y: (nodes.kneeL.y + nodes.kneeR.y) / 2 - 30
    };
    const shoesCtr = {
      x: (nodes.footL.x + nodes.footR.x) / 2,
      y: (nodes.footL.y + nodes.footR.y) / 2 - 30
    };


    const centers = [shoesCtr, legsCtr, torsoCtr, headCtr];
    console.log(centers)

    // if (isMobile) {
    //   torsoCtr.y *= 0.8;
    //   legsCtr.y *= 0.7;
    // }
    const sizes = [180, 250, 240, 130];

    const isMobile = window.innerWidth <= 768;
    if (isMobile) {
      for (let i = 0; i < sizes.length; i++) {
        sizes[i] *= 1.4;
      }
    }

    // append outfit layers: shoes ‚Üí legs ‚Üí torso ‚Üí head
    centers.forEach((ctr, i) => {
      const img = document.createElementNS(svgNS, 'image');
      img.classList.add('final-img');
      img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', selections[3 - i]);
      img.setAttribute('width', sizes[i]);
      img.setAttribute('height', sizes[i]);
      img.setAttribute('x', ctr.x - sizes[i] / 2);
      img.setAttribute('y', ctr.y - sizes[i] / 2);
      svg.appendChild(img);
    });

    // overlay face strokes on the head
    const old = svg.querySelector('#face-overlay');
    if (old) old.remove();

    const faceCanvas = document.getElementById('faceCanvas');
    if (faceCanvas.width && faceCanvas.height) {
      const faceImg = document.createElementNS(svgNS, 'image');
      faceImg.id = 'face-overlay';              // <-- stable id
      faceImg.classList.add('final-img');
      faceImg.setAttributeNS('http://www.w3.org/1999/xlink', 'href', faceCanvas.toDataURL('image/png'));
      faceImg.setAttribute('width', sizes[3]);
      faceImg.setAttribute('height', sizes[3]);
      faceImg.setAttribute('x', headCtr.x - sizes[3] / 2);
      faceImg.setAttribute('y', headCtr.y - 10 - sizes[3] / 2);
      svg.appendChild(faceImg);
    }

    faceCanvas.style.display = "none";

  }



  function gatherCharacterData() {


    const selections = carousels.map(c => c.images[c.currentIndex]);
    const name = document.getElementById('charName').value;
    const favThing = document.getElementById('favThing').value;

    // capture strokes as a png data‚Äëurl
    const faceCanvas = document.getElementById('faceCanvas');
    const faceData = faceCanvas.toDataURL('image/png');

    return { selections, name, favThing, faceData };
  }

  function dataURLToBlob(dataURL) {
    if (!dataURL || !dataURL.includes(',')) {
      return new Blob();
    }
    const [header, data] = dataURL.split(',', 2);
    const mimeMatch = header.match(/:(.*?);/);
    const mime = mimeMatch ? mimeMatch[1] : 'image/png';
    const binary = atob(data);
    const len = binary.length;
    const buffer = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      buffer[i] = binary.charCodeAt(i);
    }
    return new Blob([buffer], { type: mime });
  }

  async function uploadCharacter({ name, favThing, selections, faceData }) {
    // 1) fetch the PNG blob
    const blob = dataURLToBlob(faceData);

    // 2) upload to Storage
    const fileRef = window.ref(window.storage, `avatars/${Date.now()}.png`);
    await window.uploadBytes(fileRef, blob);
    const faceUrl = await window.getDownloadURL(fileRef);

    // 3) save metadata to Firestore
    await window.addDoc(
      window.collection(window.db, "galleryCharacters"),
      {
        name,
        favThing,
        selections,
        faceUrl,
        createdAt: window.serverTimestamp()
      }
    );

    return faceUrl;
  }

  // call this **after** you write the avatar to galleryCharacters
  async function subscribeEmail(email) {
    if (!email) return;
    await addDoc(
      collection(db, "subscribers"),
      {
        email,
        createdAt: serverTimestamp()
      }
    );
  }


  function makeSafeFilename(str, fallback = 'my-pdd-avatar') {
    let s = (str || '').trim();
    if (!s) s = fallback;

    // strip diacritics
    s = s.normalize('NFKD').replace(/[\u0300-\u036f]/g, '');

    // remove illegal filename chars and control chars
    s = s.replace(/[<>:"/\\|?*\x00-\x1F]/g, '');

    // collapse spaces to dashes, trim dots/dashes at ends
    s = s.replace(/\s+/g, '-').replace(/-+/g, '-').replace(/^[-.]+|[-.]+$/g, '');

    if (!s) s = fallback;
    if (s.length > 60) s = s.slice(0, 60); // keep it short
    return s.toLowerCase();
  }



  async function getAvatarDataURL() {
    // 1) export dimensions & ViewBox
    const CANVAS_W = 1200, CANVAS_H = 1800;
    const vbW = svg.viewBox.baseVal.width;   // 800
    const vbH = svg.viewBox.baseVal.height;  // 800

    // grab character name
    const charName = document.getElementById('charName').value.trim();

    // 0) grab the selected SVG URLs & filenames
    const selections = carousels.map(c => c.images[c.currentIndex]);
    const hatFile = selections[0].split('/').pop();
    const torsoFile = selections[1].split('/').pop();
    const legsFile = selections[2].split('/').pop();
    const shoesFile = selections[3].split('/').pop();

    // 2) compute export scale & vertical nudge
    const baseScale = CANVAS_W / vbW;       // 1.5√ó
    const fillMultiplier = 2;                    // overall zoom
    const s = baseScale * fillMultiplier;
    const xOff = (CANVAS_W - vbW * s) / 2;
    const baseYOff = (CANVAS_H - vbH * s) / 2;
    const manualYOffset = 500;                  // rig‚Äôs vertical nudge
    const yOff = baseYOff + manualYOffset;

    // 3) stroke y-tweak
    const manualYAdjust = -25;

    // 4) compute part centers in VB coords
    const originVB = { x: vbW / 2, y: 100 };
    const headVB = { x: originVB.x, y: originVB.y };
    const torsoVB = {
      x: originVB.x + (baseRig.shoulderL.x + baseRig.shoulderR.x + baseRig.hipL.x + baseRig.hipR.x) / 4,
      y: originVB.y + (baseRig.shoulderL.y + baseRig.shoulderR.y + baseRig.hipL.y + baseRig.hipR.y) / 4 + 10
    };
    const legsVB = {
      x: originVB.x + (baseRig.kneeL.x + baseRig.kneeR.x) / 2,
      y: originVB.y + (baseRig.kneeL.y + baseRig.kneeR.y) / 2 + 20
    };
    const shoesVB = {
      x: originVB.x + (baseRig.footL.x + baseRig.footR.x) / 2,
      y: originVB.y + (baseRig.footL.y + baseRig.footR.y) / 2 + 40
    };
    const centersVB = [shoesVB, legsVB, torsoVB, headVB];
    const liSizesVB = [180, 200, 240, 130];

    // 5) load the four patterned SVGs
    const imgs = await Promise.all(
      selections.map(u => new Promise(res => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => res(img);
        img.src = u;
      }))
    );

    // 6) prepare canvas
    const out = document.createElement('canvas');
    out.width = CANVAS_W;
    out.height = CANVAS_H;
    const ctx = out.getContext('2d');

    // 6a) gradient background with random bottom color
    const colors = ['#9e005d', '#3fa9f5', '#22b573', '#e85e24', '#f7931e'];
    const bottomColor = colors[Math.floor(Math.random() * colors.length)];
    const grad = ctx.createLinearGradient(0, 0, 0, CANVAS_H);
    grad.addColorStop(0, 'white');
    grad.addColorStop(0.45, 'white');
    grad.addColorStop(1, bottomColor);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

    // 6b) header SVG
    const headerImg = new Image();
    headerImg.src = './assets/header-avatarexport.svg';
    await new Promise(res => headerImg.onload = res);
    const headerW = CANVAS_W;
    const headerH = headerImg.naturalHeight / headerImg.naturalWidth * headerW;
    ctx.drawImage(headerImg, 0, 0, headerW, headerH);

    // 7) character name
    ctx.font = 'bold 164px "PP Mori"';
    ctx.fillStyle = '#22b573';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(charName, CANVAS_W / 2, headerH + 0);

    // 8) draw body parts with consistent max VB size
    for (let i = 0; i < 4; i++) {
      const img = imgs[3 - i];
      const maxVB = liSizesVB[i];
      const aspect = img.naturalWidth / img.naturalHeight;

      // compute VB dimensions preserving aspect ratio
      let partVBW, partVBH;
      if (aspect >= 1) {
        partVBW = maxVB;
        partVBH = maxVB / aspect;
      } else {
        partVBH = maxVB;
        partVBW = maxVB * aspect;
      }

      // per-part extra scale
      let extraScale = 1;
      if (i === 0) extraScale = 0.95;  // hat smaller
      if (i === 1) extraScale = 1.08;
      if (i === 2) extraScale = 0.9;
      if (i === 3) extraScale = 0.90;  // head smaller

      // final pixel sizes
      const pxW = partVBW * s * extraScale;
      const pxH = partVBH * s * extraScale;

      // center in VB coords
      const ctrVB = centersVB[i];
      const baseX = ctrVB.x * s - pxW / 2 + xOff;
      let baseY = ctrVB.y * s - pxH / 2 + yOff;

      // apply vertical offsets
      if (i === 2) baseY += 10;   // legs down a bit
      if (i === 1) baseY -= 40;   // torso up
      if (i === 0) baseY -= 20;   // hat up

      ctx.drawImage(img, baseX, baseY, pxW, pxH);
    }

    // 9) stamp face strokes
    const faceCanvas = document.getElementById('faceCanvas');
    if (!faceCanvas.width || !faceCanvas.height) {
      resizeCanvasToFace();
      drawAllStrokes();
    }
    const fcW = faceCanvas.width, fcH = faceCanvas.height;
    if (fcW && fcH) {
      const headCtr = centersVB[3];
      const xF = headCtr.x * s - (fcW * s) / 2 + xOff;
      const yF = headCtr.y * s - (fcH * s) / 2 + yOff + manualYAdjust;
      ctx.drawImage(faceCanvas, 0, 0, fcW, fcH, xF, yF, fcW * s, fcH * s);
    }

    // 10) trait labels around avatar (same as exportAvatarAsPNG)

    // // build raw entries
    // let traitEntries = [
    //   { text: hairHatTraits[hatFile] || '', color: '#22b573' }, // hat
    //   { text: torsoTraits[torsoFile] || '', color: '#e91e63' }, // torso
    //   { text: legsTraits[legsFile] || '', color: '#f4b63d' }, // legs
    //   { text: shoesTraits[shoesFile] || '', color: '#2a9df4' }  // shoes
    // ];

    // // hide duplicates but keep first occurrence
    // traitEntries = dedupeEntries(traitEntries);

    // const centerX = CANVAS_W / 2, centerY = CANVAS_H / 2;
    // const positions = [
    //   { x: centerX + 350, y: centerY + 0 }, // hat label pos
    //   { x: centerX - 400, y: centerY + 250 }, // torso
    //   { x: centerX - 300, y: centerY + 500 }, // legs
    //   { x: centerX + 400, y: centerY + 620 }  // shoes
    // ];

    // ctx.font = 'bold 40px "PP Mori"';
    // ctx.textBaseline = 'middle';
    // ctx.textAlign = 'center';

    // function drawRoundRect(x, y, w, h, r) {
    //   ctx.beginPath();
    //   ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    //   ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    //   ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    //   ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y); ctx.closePath();
    // }

    // traitEntries.forEach((t, i) => {
    //   if (!t.text) return; // skip blanks (duplicates)
    //   const pos = positions[i];
    //   const label = t.text.toUpperCase();
    //   const m = ctx.measureText(label);
    //   const pad = 12;
    //   const boxW = m.width + pad * 6;
    //   const boxH = 100;
    //   const radius = boxH / 2;
    //   const angle = (Math.random() * 16 - 8) * Math.PI / 180;
    //   ctx.save();
    //   ctx.translate(pos.x, pos.y);
    //   ctx.rotate(angle);
    //   ctx.fillStyle = t.color;
    //   drawRoundRect(-boxW / 2, -boxH / 2, boxW, boxH, radius);
    //   ctx.fill();
    //   ctx.fillStyle = '#fff';
    //   ctx.fillText(label, 0, 0);
    //   ctx.restore();
    // });

    // badge size
    // order: [hat, torso, legs, shoes]
    const BADGE_W = 240;
    const BADGE_H = 240;
    // set whatever you want per position (deg). example values:
    const BADGE_ROT = [12, -6, -14, 8];

    function drawBadgeRotated(ctx, img, x, y, w, h, deg) {
      const rad = deg * Math.PI / 180;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(img, -w / 2, -h / 2, w, h);
      ctx.restore();
    }

    // build entries (same as before)
    let traitEntries = [
      { text: hairHatTraits[hatFile] || '', color: '#22b573' }, // hat
      { text: torsoTraits[torsoFile] || '', color: '#e91e63' }, // torso
      { text: legsTraits[legsFile] || '', color: '#f4b63d' }, // legs
      { text: shoesTraits[shoesFile] || '', color: '#2a9df4' }  // shoes
    ];

    // dedupe (keep first)
    traitEntries = dedupeEntries(traitEntries);

    // same positions as before
    const centerX = CANVAS_W / 2, centerY = CANVAS_H / 2;
    const positions = [
      { x: centerX + 420, y: centerY - 100 }, // right side ‚Üí +8¬∞
      { x: centerX - 430, y: centerY + 100 }, // left  side ‚Üí -8¬∞
      { x: centerX + 380, y: centerY + 400 }, // left  side ‚Üí -8¬∞
      { x: centerX - 380, y: centerY + 570 }  // right side ‚Üí +8¬∞
    ];

    // load badge images
    const badgePromises = traitEntries.map(t => {
      if (!t.text) return Promise.resolve(null);
      const url = badgeUrlFromTrait(t.text);
      return loadBadgeImage(url);
    });
    const badgeImgs = await Promise.all(badgePromises);

    badgeImgs.forEach((img, i) => {
      if (!img) return;
      const pos = positions[i];
      const tilt = BADGE_ROT[i] ?? 0; // manual per-slot tilt
      drawBadgeRotated(ctx, img, pos.x, pos.y, BADGE_W, BADGE_H, tilt);
    });


    // 11) return Data URL
    return out.toDataURL('image/png');
  }

  async function exportAvatarAsPNG() {
    // 1) export dimensions & ViewBox
    const CANVAS_W = 1200, CANVAS_H = 1800;
    const vbW = svg.viewBox.baseVal.width;  // 800
    const vbH = svg.viewBox.baseVal.height; // 800

    // grab character name
    const charName = document.getElementById('charName').value.trim();

    // 0) grab the selected SVG URLs & filenames
    const selections = carousels.map(c => c.images[c.currentIndex]);
    const hatFile = selections[0].split('/').pop();
    const torsoFile = selections[1].split('/').pop();
    const legsFile = selections[2].split('/').pop();
    const shoesFile = selections[3].split('/').pop();

    // 2) compute export scale & vertical nudge
    const baseScale = CANVAS_W / vbW;       // 1.5√ó
    const fillMultiplier = 2;                   // overall zoom
    const s = baseScale * fillMultiplier;
    const xOff = (CANVAS_W - vbW * s) / 2;
    const baseYOff = (CANVAS_H - vbH * s) / 2;
    const manualYOffset = 500;                  // rig‚Äôs vertical nudge
    const yOff = baseYOff + manualYOffset;

    // 3) stroke y-tweak
    const manualYAdjust = -25;                   // move strokes up

    // 4) compute part centers in VB coords
    const originVB = { x: vbW / 2, y: 100 };
    const headVB = { x: originVB.x, y: originVB.y };
    const torsoVB = {
      x: originVB.x + (baseRig.shoulderL.x + baseRig.shoulderR.x + baseRig.hipL.x + baseRig.hipR.x) / 4,
      y: originVB.y + (baseRig.shoulderL.y + baseRig.shoulderR.y + baseRig.hipL.y + baseRig.hipR.y) / 4 + 10
    };
    const legsVB = {
      x: originVB.x + (baseRig.kneeL.x + baseRig.kneeR.x) / 2,
      y: originVB.y + (baseRig.kneeL.y + baseRig.kneeR.y) / 2 + 20
    };
    const shoesVB = {
      x: originVB.x + (baseRig.footL.x + baseRig.footR.x) / 2,
      y: originVB.y + (baseRig.footL.y + baseRig.footR.y) / 2 + 40
    };
    const centersVB = [shoesVB, legsVB, torsoVB, headVB];
    const liSizesVB = [180, 200, 200, 130];  // max VB dimension per part

    // 5) load the four pattern images
    const urls = selections;
    const imgs = await Promise.all(
      urls.map(u => new Promise(res => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => res(img);
        img.src = u;
      }))
    );

    // 6) prepare canvas
    const out = document.createElement('canvas');
    out.width = CANVAS_W;
    out.height = CANVAS_H;
    const ctx = out.getContext('2d');

    // 6a) gradient background with random bottom color
    const colors = ['#9e005d', '#3fa9f5', '#22b573', '#e85e24', '#eabec5'];
    const bottomColor = colors[Math.floor(Math.random() * colors.length)];
    const grad = ctx.createLinearGradient(0, 0, 0, CANVAS_H);
    grad.addColorStop(0, 'white');
    grad.addColorStop(0.45, 'white');
    grad.addColorStop(1, bottomColor);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

    // 6b) header SVG
    const headerImg = new Image();
    headerImg.src = './assets/header-avatarexport.svg';
    await new Promise(res => headerImg.onload = res);
    const headerW = CANVAS_W;
    const headerH = headerImg.naturalHeight / headerImg.naturalWidth * headerW;
    ctx.drawImage(headerImg, 0, 0, headerW, headerH);

    // 7) character name
    ctx.font = 'bold 164px "PP Mori"';
    ctx.fillStyle = '#22b573';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(charName, CANVAS_W / 2, headerH + 10);

    // 8) draw body parts with consistent max VB size
    for (let i = 0; i < 4; i++) {
      const img = imgs[3 - i];
      const maxVB = liSizesVB[i];
      const aspect = img.naturalWidth / img.naturalHeight;

      // compute VB dimensions preserving aspect ratio
      let partVBW, partVBH;
      if (aspect >= 1) {
        partVBW = maxVB;
        partVBH = maxVB / aspect;
      } else {
        partVBH = maxVB;
        partVBW = maxVB * aspect;
      }

      // per-part extra scale
      let extraScale = 1;
      if (i === 0) extraScale = 0.95;  // pants +10%
      if (i === 1) extraScale = 1.08;  // pants +10%
      if (i === 3) extraScale = 0.90;  // head ‚Äì10%

      // final pixel sizes
      const pxW = partVBW * s * extraScale;
      const pxH = partVBH * s * extraScale;

      // center in VB coords
      const ctrVB = centersVB[i];
      const baseX = ctrVB.x * s - pxW / 2 + xOff;
      let baseY = ctrVB.y * s - pxH / 2 + yOff;

      // move pants up by 50px
      if (i === 2) baseY += 10;
      if (i === 1) baseY -= 40;
      if (i === 0) baseY -= 20;

      ctx.drawImage(img, baseX, baseY, pxW, pxH);
    }



    // 9) face strokes
    const faceCanvas = document.getElementById('faceCanvas');
    if (!faceCanvas.width || !faceCanvas.height) {
      resizeCanvasToFace();
      drawAllStrokes();
    }
    const fcW = faceCanvas.width, fcH = faceCanvas.height;
    if (fcW && fcH) {
      const headCtr = centersVB[3];
      const xF = headCtr.x * s - (fcW * s) / 2 + xOff;
      const yF = headCtr.y * s - (fcH * s) / 2 + yOff + manualYAdjust;
      ctx.drawImage(faceCanvas, 0, 0, fcW, fcH, xF, yF, fcW * s, fcH * s);
    }

    // // 10) trait labels around avatar
    // const traits = [
    //   { text: hairHatTraits[hatFile] || '', color: '#22b573' },
    //   { text: torsoTraits[torsoFile] || '', color: '#e91e63' },
    //   { text: legsTraits[legsFile] || '', color: '#f4b63d' },
    //   { text: shoesTraits[shoesFile] || '', color: '#2a9df4' }
    // ];
    // const centerX = CANVAS_W / 2, centerY = CANVAS_H / 2;
    // const positions = [
    //   { x: centerX + 350, y: centerY + 0 },
    //   { x: centerX - 400, y: centerY + 250 },
    //   { x: centerX - 300, y: centerY + 500 },
    //   { x: centerX + 400, y: centerY + 620 }
    // ];
    // // helper
    // function drawRoundRect(x, y, w, h, r) {
    //   ctx.beginPath();
    //   ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    //   ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    //   ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    //   ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y); ctx.closePath();
    // }
    // ctx.font = 'bold 40px "PP Mori"'; ctx.textBaseline = 'middle'; ctx.textAlign = 'center';
    // traits.forEach((t, i) => {
    //   if (!t.text) return;
    //   const pos = positions[i];
    //   const label = t.text.toUpperCase();
    //   const metrics = ctx.measureText(label);
    //   const padding = 12;
    //   const boxW = metrics.width + padding * 6;
    //   const boxH = 100;
    //   const radius = boxH / 2;
    //   // random tilt ¬±8¬∞
    //   const deg = Math.random() * 16 - 8;
    //   const angle = deg * Math.PI / 180;
    //   ctx.save();
    //   ctx.translate(pos.x, pos.y);
    //   ctx.rotate(angle);
    //   ctx.fillStyle = t.color;
    //   drawRoundRect(-boxW / 2, -boxH / 2, boxW, boxH, radius);
    //   ctx.fill();
    //   ctx.fillStyle = '#fff';
    //   ctx.fillText(label, 0, 0);
    //   ctx.restore();
    // });

    // badge size
    // order: [hat, torso, legs, shoes]
    const BADGE_W = 240;
    const BADGE_H = 240;
    // set whatever you want per position (deg). example values:
    const BADGE_ROT = [12, -6, -14, 8];

    function drawBadgeRotated(ctx, img, x, y, w, h, deg) {
      const rad = deg * Math.PI / 180;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(img, -w / 2, -h / 2, w, h);
      ctx.restore();
    }

    // build entries (same as before)
    let traitEntries = [
      { text: hairHatTraits[hatFile] || '', color: '#22b573' }, // hat
      { text: torsoTraits[torsoFile] || '', color: '#e91e63' }, // torso
      { text: legsTraits[legsFile] || '', color: '#f4b63d' }, // legs
      { text: shoesTraits[shoesFile] || '', color: '#2a9df4' }  // shoes
    ];

    // dedupe (keep first)
    traitEntries = dedupeEntries(traitEntries);

    // same positions as before
    const centerX = CANVAS_W / 2, centerY = CANVAS_H / 2;
    const positions = [
      { x: centerX + 420, y: centerY - 100 }, // right side ‚Üí +8¬∞
      { x: centerX - 430, y: centerY + 100 }, // left  side ‚Üí -8¬∞
      { x: centerX + 380, y: centerY + 400 }, // left  side ‚Üí -8¬∞
      { x: centerX - 380, y: centerY + 570 }  // right side ‚Üí +8¬∞
    ];

    // load badge images
    const badgePromises = traitEntries.map(t => {
      if (!t.text) return Promise.resolve(null);
      const url = badgeUrlFromTrait(t.text);
      return loadBadgeImage(url);
    });
    const badgeImgs = await Promise.all(badgePromises);

    badgeImgs.forEach((img, i) => {
      if (!img) return;
      const pos = positions[i];
      const tilt = BADGE_ROT[i] ?? 0; // manual per-slot tilt
      drawBadgeRotated(ctx, img, pos.x, pos.y, BADGE_W, BADGE_H, tilt);
    });







    // 11) trigger download
    const link = document.createElement('a');
    const safeBase = makeSafeFilename(charName, 'my-pdd-avatar');
    link.download = `${safeBase}.png`;
    link.href = out.toDataURL('image/png');
    link.click();

  }

  const infoToggle = document.getElementById('info-toggle');
  infoToggle.addEventListener('click', () => {
    document.body.classList.toggle('info-open');
  });

  const infoClose = document.getElementById('info-close');
  infoClose.addEventListener('click', () => {
    document.body.classList.remove('info-open');
  });


  const emailConsent = document.getElementById('emailConsent');
  const emailInput = document.getElementById('emailAddress');

  emailConsent.addEventListener('change', () => {
    emailInput.disabled = !emailConsent.checked;
    if (!emailConsent.checked) {
      emailInput.value = '';
    }
  });

  const alertBox = document.getElementById('custom-alert');
  const alertMsg = document.getElementById('custom-alert__message');
  const btnGallery = document.getElementById('custom-alert__gallery');
  const btnAnother = document.getElementById('custom-alert__another');
  const btntoHome = document.getElementById('custom-alert__home');

  const btnSave = document.getElementById('custom-alert__save');
  btnSave.addEventListener('click', () => {
    exportAvatarAsPNG();
  });


  function showAlert(message) {
    alertMsg.textContent = message;
    alertBox.style.display = 'flex';
  }

  // wire up the two buttons
  btnGallery.addEventListener('click', () => {
    alertBox.style.display = 'none';
    window.location.href = './gallery.html';
  });

  btnAnother.addEventListener('click', () => {
    alertBox.style.display = 'none';
    window.location.href = './char.html';
  });

  btntoHome.addEventListener('click', () => {
    alertBox.style.display = 'none';
    window.location.href = './index.html';
  });






  // click‚Äêhandler for NEXT in stage 1
  nextBtn.addEventListener('click', () => {
    if (stage === 1) {
      // ‚Üí stage-1 ‚Üí stage-2  
      applyPatterned(carousels);
      // subtitleEl.textContent = "Next, pick patterns and prints!";

      setStep(1);
      stage = 2;
      updateTitleSection(stage);
      backBtn.classList.add('active');
      footer.classList.replace('stage-1', 'stage-2');
      document.body.classList.remove('stage-1');
      document.body.classList.add('stage-2');

      root.classList.remove('stage-1');
      root.classList.add('stage-2');
    }
    else if (stage === 2) {
      // ‚Üí stage-2 ‚Üí stage-3  
      root.classList.remove('stage-2');
      root.classList.add('stage-3');           // trigger zoom & hide other parts
      // subtitleEl.textContent = "Now you should draw a face!";

      setStep(2);
      // show drawing tools
      toolbarEl.style.display = 'flex';
      canvasEl.style.display = 'block';
      // size overlay AFTER zoom CSS finishes
      // setTimeout(resizeCanvasToFace, 300);
      setTimeout(() => {
        resizeCanvasToFace();
        layoutSwatchesInArc();
        placeUndoNearSwatches(); // <‚Äî add
      }, 300);


      stage = 3;
      updateTitleSection(stage);


    }
    else if (stage === 3) {
      root.classList.replace('stage-3', 'stage-4');

      // hide the palette but keep the canvas visible
      toolbarEl.style.display = 'none';
      canvasEl.style.display = 'none';
      // 1) resize & scale the face canvas to the head SVG
      resizeCanvasToFace();
      // 2) redraw strokes so they're scaled correctly
      drawAllStrokes();

      // 3) now draw just the four printed svgs on the rig
      drawFinalRig();
      const faceCanvas = document.getElementById('faceCanvas');
      faceCanvas.style.display = 'none';

      console.log("DATA", gatherCharacterData());
      // 4) update UI
      stage = 4;
      updateTitleSection(stage);
      updateTraitCards();
      nextBtn.textContent = 'SUBMIT';
      nextBtn.classList.replace('blue-bg', 'red-bg');
      nextBtn.type = 'submit';
      enableSubmitOnlyAtBottom();

    }

    else if (stage === 4) {
      // 1Ô∏è‚É£ show T&C modal
      const tcModal = document.getElementById('tc-modal');
      const agreeBtn = document.getElementById('tc-agree');
      const loader = document.getElementById('loading-overlay');

      tcModal.style.display = 'flex';

      agreeBtn.onclick = async () => {
        // hide modal, show loader
        tcModal.style.display = 'none';
        loader.style.display = 'flex';

        try {
          exportAvatarAsPNG();
          // gather data
          const data = gatherCharacterData();
          const consent = document.getElementById('emailConsent').checked;
          const email = document.getElementById('emailAddress').value.trim();

          // upload character
          const faceUrl = await uploadCharacter(data);

          // if they opted in, send email
          if (consent && email) {
            const dataUrl = await getAvatarDataURL();
            const base64 = dataUrl.split(',')[1];

            const safeBase = makeSafeFilename(data.name, 'my-pdd-avatar');

            await addDoc(
              collection(db, 'mail'),
              {
                to: email,
                message: {
                  subject: 'üéâ Your PDD avatar is ready!',
                  html: `<p>Hi there,</p>
<p>Your PDD avatar is ready, and it‚Äôs attached to this email as an image. We hope you had fun creating it!</p>
<hr>
<h3>üé® Meet the Artists Behind the Mural</h3>
<p>Your avatar‚Äôs outfit, shapes, and patterns are inspired by the beautiful works of <a href="https://shapinghearts.cdc.gov.sg/ezra-chan-yi/" target="_blank">Ezra Chan Yi</a> and <a href="https://shapinghearts.cdc.gov.sg/simeon-tan-rui-en/" target="_blank">Simeon Tan Rui En</a>, two talented artists with disabilities from Shaping Hearts. Their creative contributions are part of a collaborative mural celebrating inclusivity, expression, and the power of community through art.</p>
<hr>
<h3>‚ú® See Your Avatar Come to Life</h3>
<p>Your character will be featured in an epic <strong>132-metre mural</strong> at the Punggol Digital District Community Promenade, launching on <strong>16 November 2025</strong>. With the help of Augmented Reality (AR), you‚Äôll even be able to see your avatar move and interact right on the mural itself! So make sure to come on down and visit.</p>
<p>Thank you for being part of this community experience, and we can‚Äôt wait for you to see it live!</p>
<p>With Love,<br>The People of PDD Team</p>`,
                  attachments: [
                    {
                      filename: `${safeBase}.png`,
                      content: base64,
                      encoding: 'base64',
                      type: 'image/png'
                    }
                  ]
                },
                createdAt: serverTimestamp()
              }
            );
          }

          console.log('‚úÖ upload + mail enqueue successful');
          loader.style.display = 'none';
          showAlert('Successfully submitted your avatar! üéâ');
        } catch (err) {
          loader.style.display = 'none';
          console.error('upload or mail enqueue failed', err);
          alert('upload failed‚Äîcheck console');
        }
      };
    }



  });


  // click‚Äêhandler for BACK in stage 2
  backBtn.addEventListener('click', () => {
    if (stage === 3) {
      // ‚Üí stage-3 ‚Üí stage-2
      root.classList.remove('stage-3');
      root.classList.add('stage-2');
      // subtitleEl.textContent = "Next, pick patterns and prints!";
      setStep(1);
      toolbarEl.style.display = 'none';
      canvasEl.style.display = 'none';
      stage = 2;
      updateTitleSection(stage);
      requestAnimationFrame(() => {
        carousels.forEach(c => c.positionNavButtons());
      });

      // footer is already in stage-2, backBtn stays visible
    }
    else if (stage === 2) {
      // ‚Üí stage-2 ‚Üí stage-1
      root.classList.remove('stage-2');
      root.classList.add('stage-1');
      restoreOriginals(carousels);
      subtitleEl.textContent = originalSubtitle;
      setStep(0);
      backBtn.classList.remove('active');
      footer.classList.replace('stage-2', 'stage-1');
      stage = 1;
      updateTitleSection(stage);
      requestAnimationFrame(() => {
        carousels.forEach(c => c.positionNavButtons());
      });
    }

    else if (stage === 4) {
      // ‚Üí stage-4 ‚Üí stage-3
      // 1) swap CSS
      root.classList.replace('stage-4', 'stage-3');
      // Leaving stage-4: unbind bottom-reveal behavior
      disableSubmitOnlyAtBottom();

      // 2) bring back the draw tools
      toolbarEl.style.display = 'flex';
      canvasEl.style.display = 'block';

      // 3) un-hide the four divs
      ['head', 'torso', 'legs', 'shoes'].forEach(cat => {
        const el = document.querySelector(`.${cat}`);
        if (el) el.style.display = '';
      });
      // 4) show nav buttons again
      document.querySelectorAll('.carousel-nav').forEach(btn => {
        btn.style.display = 'inline-flex';
      });

      // 5) remove the final <image> overlays
      document.querySelectorAll('image.final-img').forEach(img => img.remove());

      // 6) re-scale & redraw strokes
      setTimeout(() => {
        resizeCanvasToFace();
        drawAllStrokes();
        layoutSwatchesInArc();
        placeUndoNearSwatches(); // <‚Äî add
      }, 0);



      // 7) reset UI state
      stage = 3;
      updateTitleSection(stage);
      nextBtn.textContent = 'NEXT';
      nextBtn.classList.replace('red-bg', 'blue-bg');
      nextBtn.type = 'button';

    }
  });


</script>

<script>
  // --- Transparent export (R key) ---
  async function exportAvatarTransparentPNG() {
    // canvas size (same aspect you already use)
    const CANVAS_W = 1200, CANVAS_H = 1800;

    // current selections
    const selections = carousels.map(c => c.images[c.currentIndex]);
    // viewBox + rig math (mirrors your exportAvatarAsPNG)
    const vbW = svg.viewBox.baseVal.width;   // 800
    const vbH = svg.viewBox.baseVal.height;  // 800

    const baseScale = CANVAS_W / vbW;
    const fillMultiplier = 2;                // same overall zoom
    const s = baseScale * fillMultiplier;
    const xOff = (CANVAS_W - vbW * s) / 2;
    const baseYOff = (CANVAS_H - vbH * s) / 2;
    const manualYOffset = 500;
    const yOff = baseYOff + manualYOffset;

    // compute VB-space centers (same as your other exporter)
    const originVB = { x: vbW / 2, y: 100 };
    const headVB = { x: originVB.x, y: originVB.y };
    const torsoVB = {
      x: originVB.x + (baseRig.shoulderL.x + baseRig.shoulderR.x + baseRig.hipL.x + baseRig.hipR.x) / 4,
      y: originVB.y + (baseRig.shoulderL.y + baseRig.shoulderR.y + baseRig.hipL.y + baseRig.hipR.y) / 4 + 10
    };
    const legsVB = {
      x: originVB.x + (baseRig.kneeL.x + baseRig.kneeR.x) / 2,
      y: originVB.y + (baseRig.kneeL.y + baseRig.kneeR.y) / 2 + 20
    };
    const shoesVB = {
      x: originVB.x + (baseRig.footL.x + baseRig.footR.x) / 2,
      y: originVB.y + (baseRig.footL.y + baseRig.footR.y) / 2 + 40
    };
    const centersVB = [shoesVB, legsVB, torsoVB, headVB];

    // max VB dimensions per part (matches your export)
    const liSizesVB = [180, 200, 200, 130];

    // load the 4 part images
    const imgs = await Promise.all(
      selections.map(u => new Promise(res => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => res(img);
        img.src = u;
      }))
    );

    // prepare transparent canvas
    const out = document.createElement('canvas');
    out.width = CANVAS_W;
    out.height = CANVAS_H;
    const ctx = out.getContext('2d');

    // draw body parts only (no bg, no header, no text, no badges)
    for (let i = 0; i < 4; i++) {
      const img = imgs[3 - i];
      const maxVB = liSizesVB[i];
      const aspect = img.naturalWidth / img.naturalHeight;

      // scale to fit maxVB while preserving aspect
      let partVBW, partVBH;
      if (aspect >= 1) {
        partVBW = maxVB;
        partVBH = maxVB / aspect;
      } else {
        partVBH = maxVB;
        partVBW = maxVB * aspect;
      }

      // per-part extra scale (same tweaks you used)
      let extraScale = 1;
      if (i === 0) extraScale = 0.95; // shoes/hat slot in your stacking
      if (i === 1) extraScale = 1.08; // legs/torso slot
      if (i === 3) extraScale = 0.90; // head slot

      const pxW = partVBW * s * extraScale;
      const pxH = partVBH * s * extraScale;

      const ctrVB = centersVB[i];
      const baseX = ctrVB.x * s - pxW / 2 + xOff;
      let baseY = ctrVB.y * s - pxH / 2 + yOff;

      // your small offsets
      if (i === 2) baseY += 10;  // legs down a bit
      if (i === 1) baseY -= 40;  // torso up
      if (i === 0) baseY -= 20;  // shoes/hat up

      ctx.drawImage(img, baseX, baseY, pxW, pxH);
    }

    // add face strokes if present
    const faceCanvas = document.getElementById('faceCanvas');
    const manualYAdjust = -25;  // same stroke nudge
    if (!faceCanvas.width || !faceCanvas.height) {
      // ensure canvas is sized + strokes drawn if stage changed
      resizeCanvasToFace();
      drawAllStrokes();
    }
    const fcW = faceCanvas.width, fcH = faceCanvas.height;
    if (fcW && fcH) {
      const headCtr = centersVB[3];
      const xF = headCtr.x * s - (fcW * s) / 2 + xOff;
      const yF = headCtr.y * s - (fcH * s) / 2 + yOff + manualYAdjust;
      ctx.drawImage(faceCanvas, 0, 0, fcW, fcH, xF, yF, fcW * s, fcH * s);
    }

    // download
    const charName = document.getElementById('charName').value.trim();
    const safeBase = makeSafeFilename(charName, 'my-pdd-avatar');
    const a = document.createElement('a');
    a.download = `${safeBase}.png`;
    a.href = out.toDataURL('image/png'); // keeps alpha
    a.click();
  }

  // hotkey: press "R" to export transparent avatar
  // window.addEventListener('keydown', (e) => {
  //   if (e.key === 'r' || e.key === 'R') {
  //     e.preventDefault();
  //     exportAvatarTransparentPNG();
  //   }
  // });
</script>


</html>