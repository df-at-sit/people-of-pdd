<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
    <title>Character Gallery</title>

    <style>
        /* Reset */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'PP Mori', sans-serif;
            background: white;
            color: #2a9df4;
        }

        /* HERO HEADER */
        .hero {
            width: 100%;
            position: sticky;
            top: 0;
            z-index: 6000;
            background: white;
            padding: 16px 22px;
        }

        .hero-inner {
            background: linear-gradient(135deg, #fff6dc, #f4b63d);
            border-radius: 24px;
            padding: 20px;
            box-shadow: 0 20px 40px rgba(244, 182, 61, 0.2);
            max-width: 1200px;
            margin: 0 auto;
            transition: padding 0.25s ease, box-shadow 0.25s ease;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .hero-nav {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            background: #58aaf7;
            border-radius: 999px;
            padding: 8px 12px;
        }

        .hero-body {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: 18px;
        }

        .hero-copy {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .hero-search {
            width: 100%;
        }

        .hero-search .search-container {
            width: 100%;
        }

        .hero-eyebrow {
            font-size: 0.75rem;
            letter-spacing: 0.25em;
            text-transform: uppercase;
            color: #c13a00;
            margin-bottom: 8px;
        }

        .hero-title {
            color: #f7931e;
            font-size: clamp(2.2rem, 4vw, 3rem);
            text-transform: uppercase;
            margin-bottom: 12px;
            display: inline-block;
            transform: rotate(-1.5deg);
            transform-origin: left center;
            text-shadow: 0 6px 25px rgba(247, 147, 30, 0.35);
            transition: font-size 0.25s ease, transform 0.25s ease;
        }

        .hero-subcopy {
            color: #7a3b00;
            font-size: 1rem;
            max-width: 520px;
            line-height: 1.4;
            transition: opacity 0.25s ease, transform 0.25s ease, max-height 0.25s ease, margin 0.25s ease;
            max-height: 220px;
            overflow: hidden;
        }

        .hero-meta {
            display: flex;
            gap: 14px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            margin-top: 18px;
            transition: opacity 0.25s ease, transform 0.25s ease, max-height 0.25s ease, margin 0.25s ease;
            max-height: 140px;
            overflow: hidden;
        }

        .hero-stat {
            background: #fff;
            border-radius: 12px;
            padding: 4px 10px;
            min-width: auto;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: opacity 0.25s ease, transform 0.25s ease;
        }

        .hero-stat strong,
        .hero-stat span {
            font-size: 0.85rem;
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #2a9df4;
            line-height: 1;
        }

        .hero-tips-link {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: #fff;
            border: none;
            border-radius: 12px;
            padding: 4px 10px;
            color: #c13a00;
            font-weight: 700;
            font-size: 0.85rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .hero-card {
            flex: 1 1 260px;
            max-width: 340px;
            background: #fff;
            border-radius: 22px;
            padding: 18px 20px;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.08);
            overflow: hidden;
            transition: opacity 0.25s ease, transform 0.25s ease;
            margin: 0 auto;
        }

        .hero-card h3 {
            margin-bottom: 10px;
            color: #c13a00;
            text-transform: uppercase;
            font-size: 0.95rem;
        }

        .hero-card ul {
            list-style: none;
            color: #2a9df4;
            line-height: 1.4;
            font-size: 0.95rem;
            padding-left: 0;
        }

        .hero-card li::before {
            content: '•';
            color: #f4b63d;
            margin-right: 6px;
        }

        .hero-tips-panel {
            display: none;
            margin-top: 18px;
            background: #fff;
            border-radius: 18px;
            padding: 16px 20px;
            color: #2a9df4;
            font-size: 0.9rem;
            box-shadow: inset 0 0 0 1px rgba(42, 157, 244, 0.15);
        }

        .hero-tips-panel.open {
            display: block;
        }

        .hero-scroll-cta {
            margin-top: 12px;
            display: flex;
            justify-content: center;
        }

        .hero-scroll-cta button {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            border: none;
            border-radius: 999px;
            padding: 12px 28px;
            background: #f7931e;
            color: #fff;
            font-weight: 700;
            text-transform: uppercase;
            font-size: 0.85rem;
            letter-spacing: 0.08em;
            cursor: pointer;
            box-shadow: 0 10px 25px rgba(247, 147, 30, 0.35);
        }

        .hero.is-condensed .hero-inner {
            padding: 12px 16px;
            box-shadow: 0 12px 26px rgba(244, 182, 61, 0.18);
        }

        .hero.is-condensed .hero-title {
            font-size: clamp(1.8rem, 3vw, 2.3rem);
            transform: rotate(-0.5deg);
        }

        .hero.is-condensed .hero-subcopy {
            font-size: 0.9rem;
            max-width: 420px;
        }

        .hero.is-condensed .hero-card {
            opacity: 0;
            pointer-events: none;
            transform: translateY(-10px);
            height: 0;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }

        .hero.is-condensed .hero-scroll-cta {
            display: none;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }

        .circle-button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            color: #2a9df4;
            background-color: #fff;
            font-size: 1.2rem;
            border: none;
            cursor: pointer;
            margin-right: 10px;
        }

        .text-back {
            padding: 10px 20px;
            border-radius: 20px;
            color: #2a9df4;
            background-color: white;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.9rem;
            border: none;
            cursor: pointer;
        }

        .header-center h1 {
            color: #c13a00;
            text-transform: uppercase;
            font-size: 2rem;
            margin: 0;
        }

        .subtitle {
            color: #fff;
            font-weight: bold;
            font-size: 1.2rem;
            margin: 5px 0 0;
        }

        .search-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .search-container input {
            padding: 8px 14px;
            border: 2px solid #2a9df4;
            border-radius: 20px;
            font-size: 0.9rem;
            font-family: 'PP Mori', sans-serif;
            text-transform: uppercase;
            color: #2a9df4;
            outline: none;
            width: min(280px, 100%);
        }

        .search-container input::placeholder {
            color: #2a9df4;
            opacity: 0.8;
        }

        .search-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #2a9df4;
            background-color: #2a9df4;
            color: #fff;
            font-size: 1.1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .search-btn:hover {
            background-color: #1e7fd1;
        }

        /* FOOTER */
        .footer-section {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 50px;
            text-align: center;
            background: url("./assets/wave-gallery.svg") no-repeat bottom center;
            background-position: center calc(100% + 40px);
            background-size: 100% auto;
            z-index: 20;
        }

        /* GALLERY */
        #gallery-container {
            position: relative;
            width: 100%;
            height: calc(100vh - 140px);
            overflow: visible;
            z-index: 2;
            margin-bottom: 500px;
            margin-top: 50px;
        }

        .gallery-card {
            position: absolute;
            transform-origin: center center;
            transition: left 0.4s ease, top 0.4s ease, opacity 0.3s ease, transform 0.3s ease;
            opacity: 1;
            transform: scale(1);
            cursor: pointer;
        }

        .gallery-card:hover {
            transform: scale(1.5) !important;
        }

        .gallery-card.zoomed {
            transform: scale(1.5) !important;
            z-index: 9999;
        }

        /* TOOLTIP */
        .tooltip {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translate(-50%, -110%) scale(0.1);
            padding: 10px 10px;
            background-color: #2a9df4;
            border-radius: 10px;
            border: 2px solid #fff;
            opacity: 0;
            pointer-events: none;
            z-index: 100;
            transition: opacity 0.2s ease-out, transform 0.2s ease-out;
            min-width: 160px;
            max-width: 200px;
            text-align: center;
        }

        .tooltip::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 7px 7px 0 7px;
            border-style: solid;
            border-color: #2a9df4 transparent transparent transparent;
        }

        .tooltip h3 {
            margin: 0 0 6px;
            color: #fff;
            text-transform: uppercase;
            font-size: 0.9rem;
            text-align: center;
        }

        .tooltip p {
            margin: 0 0 10px;
            color: #ffe699;
            font-size: 0.65rem;
            text-align: center;
        }

        .tooltip .ar-btn {
            display: inline-block;
            padding: 8px 12px;
            border-radius: 16px;
            border: 2px solid #fff;
            color: #2a9df4;
            background: #fff;
            font-weight: 700;
            font-size: 0.75rem;
            text-transform: uppercase;
            cursor: pointer;
        }

        .gallery-card.show-tip .tooltip {
            opacity: 1;
            transform: translate(-50%, -110%) scale(1);
            pointer-events: auto;
        }

        .back-to-top {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: none;
            color: #2a9df4;
            background-color: #fff;
            font-size: 1.4rem;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            z-index: 7000;
            transition: opacity 0.3s ease;
            opacity: 0;
            pointer-events: none;
        }

        .back-to-top:hover {
            background: #1e7fd1;
        }

        @media (max-width: 900px) {
            .hero {
                position: static;
                padding: 12px;
            }

            .hero-inner {
                padding: 18px;
            }

            .hero-nav,
            .hero-search {
                width: 100%;
            }

            .hero-meta {
                gap: 10px;
                flex-direction: column;
                align-items: flex-start;
            }

            .hero-card {
                display: none;
            }
        }

        /* tighten mobile hero */
        @media (max-width: 600px) {
            .hero {
                padding: env(safe-area-inset-top, 16px) 12px 12px;
            }

            .hero-inner {
                padding: 20px;
            }

            .hero-nav {
                justify-content: space-between;
            }

            .search-container {
                width: 100%;
                gap: 8px;
            }

            .search-container input {
                flex: 1;
                width: auto;
            }

            .hero-meta {
                align-items: flex-start;
            }

            .back-to-top {
                bottom: 20px;
                right: 20px;
                width: 48px;
                height: 48px;
                border-radius: 50%;
                border: none;
                background: #2a9df4;
                color: #fff;
                font-size: 1.4rem;
                cursor: pointer;
                box-shadow: 0 4px 10px rgba(255, 255, 255, 0.2);
                z-index: 7000;
                transition: opacity 0.3s ease;
                opacity: 0;
                pointer-events: none;
            }

            .back-to-top:hover {
                background: #1e7fd1;
            }
        }

        /* desktop hover */
        @media (hover: hover) and (pointer: fine) {
            .gallery-card:hover {
                transform: scale(1.5) !important;
            }
        }

        @media (min-width: 901px) {
            .hero {
                padding: 18px 36px 20px;
            }

            .hero-inner {
                padding: 24px 30px;
                display: grid;
                grid-template-columns: auto 1fr auto;
                align-items: start;
                gap: 12px 28px;
            }

            .hero-nav {
                grid-column: 1;
                justify-self: flex-start;
                align-self: start;
            }

            .hero-body {
                grid-column: 2;
                align-self: start;
                align-items: flex-start;
                text-align: left;
                gap: 12px;
            }

            .hero-copy {
                align-items: flex-start;
            }

            .hero-meta {
                justify-content: flex-start;
            }

            .hero-search {
                grid-column: 3;
                width: auto;
                justify-self: flex-end;
                align-self: start;
            }

            .hero-search .search-container {
                width: auto;
            }

            .search-container input {
                font-size: 0.85rem;
                padding: 6px 12px;
            }

            .search-btn {
                width: 36px;
                height: 36px;
                font-size: 1rem;
            }

            .hero-scroll-cta {
                grid-column: 2;
                justify-content: flex-start;
                margin-top: 0;
            }

            .hero-tips-panel {
                grid-column: 1 / -1;
            }

            .hero-card {
                display: none;
            }

            .hero.is-condensed .hero-inner {
                padding: 12px 20px;
                box-shadow: 0 8px 18px rgba(244, 182, 61, 0.12);
            }

            .hero.is-condensed .hero-title {
                font-size: clamp(1.4rem, 2vw, 2rem);
            }

            .hero.is-condensed .hero-subcopy {
                font-size: 0.85rem;
            }

            .hero.is-muted .hero-subcopy,
            .hero.is-muted .hero-meta {
                opacity: 0;
                transform: translateY(-6px);
                pointer-events: none;
                max-height: 0;
                margin-top: 0;
            }

            .hero.is-muted .hero-meta .hero-stat,
            .hero.is-muted .hero-meta .hero-tips-link {
                opacity: 0;
                transform: translateY(-6px);
            }
        }

        /* Slightly shrink buttons globally so the bar looks shorter */
        .circle-button {
            width: 36px;
            height: 36px;
            font-size: 1rem;
        }

        .text-back {
            padding: 8px 14px;
            border-radius: 16px;
            font-size: 0.82rem;
        }
    </style>

    <!-- model-viewer (v3+) -->
    <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>

    <!-- firebase init -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-app.js";
        import { getFirestore, collection, query, orderBy, getDocs }
            from "https://www.gstatic.com/firebasejs/12.0.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDwpNjnDFAA_5P64zMOt-GTSOdETx2xKJQ",
            authDomain: "people-of-pdd-website.firebaseapp.com",
            projectId: "people-of-pdd-website",
            storageBucket: "people-of-pdd-website.firebasestorage.app",
            messagingSenderId: "685048567158",
            appId: "1:685048567158:web:abc51754b5b785219c1657",
            measurementId: "G-1VRMYRMXKN"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // expose to non-module scripts
        window.db = db;
        window.collection = collection;
        window.query = query;
        window.orderBy = orderBy;
        window.getDocs = getDocs;
    </script>

    <!-- AR modal styles (additions) -->
    <style>
        .ar-modal {
            position: fixed;
            inset: 0;
            background: rgba(255, 255, 255, .7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 99999;
        }

        .ar-modal.open {
            display: flex;
        }

        .ar-wrap {
            position: relative;
            width: min(100vw, 100vh);
            height: min(100vw, 100vh);
            background: #fff;
            border-radius: 12px;
            overflow: hidden;
        }

        .ar-close {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 2;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: #fff;
            color: #2a9df4;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(255, 255, 255, .4);
        }

        model-viewer#arMV {
            width: 100%;
            height: 100%;
            background: #fff;
        }

        /* Modal container */
        .ar-modal {
            position: fixed;
            inset: 0;
            background: rgba(255, 255, 2555, .7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 99999;
        }

        .ar-modal.open {
            display: flex;
        }

        /* Wrapper keeps a nice square and rounds corners */
        .ar-wrap {
            position: relative;
            width: min(94vw, 94vh);
            height: min(94vw, 94vh);
            background: #fff;
            /* keep dark behind the model */
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(255, 255, 255, .35);
        }

        /* Top bar */
        .ar-topbar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 54px;
            display: flex;
            align-items: center;
            justify-content: center;
            /* background: linear-gradient(to bottom, rgba(224, 0, 0, 0.75), rgba(0, 0, 0, 0)); */
            z-index: 3;
            pointer-events: none;
            /* allow model-viewer controls through */
        }

        .ar-topbar h3 {
            margin: 0;
            color: #fff;
            letter-spacing: .5px;
            font-size: 16px;
            text-transform: uppercase;
            font-weight: 800;
            pointer-events: none;
        }

        .ar-close {
            position: absolute;
            right: 10px;
            top: 10px;
            z-index: 4;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: #fff;
            color: #2a9df4;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, .35);
            pointer-events: auto;
            /* clickable */
        }

        /* Model-viewer fills the box */
        model-viewer#arMV {
            width: 100%;
            height: 100%;
            background: transparent;
        }

        /* Bottom help panel */
        .ar-help {
            position: absolute;
            left: 16px;
            right: 16px;
            bottom: 16px;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.95);
            color: #2a9df4;
            padding: 18px;
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.25);
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            align-items: center;
            z-index: 4;
        }

        .ar-preview {
            width: 96px;
            height: 96px;
            border-radius: 18px;
            overflow: hidden;
            border: 2px solid rgba(42, 157, 244, 0.35);
            background: rgba(42, 157, 244, 0.08);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .ar-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .ar-status-block {
            flex: 1 1 180px;
            min-width: 220px;
        }

        .ar-status-block p {
            margin-top: 6px;
            font-size: 0.85rem;
            color: #2a9df4;
        }

        .ar-status-chip {
            display: inline-flex;
            align-items: center;
            border-radius: 999px;
            padding: 4px 12px;
            font-size: 0.75rem;
            text-transform: uppercase;
            font-weight: 700;
            background: #edf6ff;
            color: #2a9df4;
        }

        .ar-status-chip[data-state="building"] {
            background: #fff1cf;
            color: #a45c00;
        }

        .ar-status-chip[data-state="ready"] {
            background: #daffe2;
            color: #04703d;
        }

        .ar-status-chip[data-state="error"] {
            background: #ffe4e4;
            color: #c54141;
        }

        .ar-checklist {
            list-style: none;
            margin: 0;
            padding: 0;
            flex: 1 1 220px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.82rem;
        }

        .ar-checklist li {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .ar-checklist span {
            width: 20px;
            height: 20px;
            background: #2a9df4;
            border-radius: 50%;
            color: #fff;
            font-size: 0.8rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
        }

        .ar-device-note {
            flex: 1 1 200px;
            font-size: 0.78rem;
            color: #2a9df4;
        }

        .ar-device-note p {
            margin: 0;
            line-height: 1.4;
        }

        .ar-launch {
            margin-left: auto;
            border: none;
            border-radius: 18px;
            padding: 12px 24px;
            font-weight: 700;
            background: #2a9df4;
            color: #fff;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .ar-launch:disabled {
            background: #8fc1ea;
            cursor: not-allowed;
        }

        @media (max-width: 480px) {
            .ar-help {
                font-size: 0.78rem;
            }

            .ar-preview {
                width: 80px;
                height: 80px;
            }
        }

        @media (max-width: 600px) {
            .ar-wrap {
                width: 100vw;
                height: 100vh;
                border-radius: 0;
            }

            .ar-topbar {
                padding: 0 12px;
                justify-content: space-between;
            }

            .ar-topbar h3 {
                font-size: 0.85rem;
            }

            .ar-help {
                position: static;
                width: 100%;
                border-radius: 0;
                box-shadow: none;
                padding: 16px;
                gap: 12px;
                overflow-y: auto;
                max-height: 40vh;
            }

            .ar-status-block,
            .ar-checklist,
            .ar-device-note,
            .ar-launch {
                width: 100%;
            }

            model-viewer#arMV {
                height: 60vh;
            }
        }
    </style>
</head>

<body>
    <header class="hero">
        <div class="hero-inner">
            <div class="hero-nav">
                <button id="goBackMain" class="circle-button" onclick="goBack()">←</button>
                <button class="text-back" onclick="goBack()">BACK TO MAIN PAGE</button>
            </div>
            <div class="hero-body">
                <div class="hero-copy">
                    <p class="hero-eyebrow">People of PDD</p>
                    <h1 class="hero-title">Step into the Gallery</h1>
                    <p class="hero-subcopy">Browse every neighbour, learn their quirks, then launch them into your space
                        with AR.</p>
                    <div class="hero-meta">
                        <div class="hero-stat">
                            <strong id="statTotal">0</strong>
                            <span>characters</span>
                        </div>
                        <button class="hero-tips-link" type="button" id="arTipsToggle">View AR tips →</button>
                    </div>
                </div>
                <div class="hero-card">
                    <h3>How it works</h3>
                    <ul>
                        <li>Pick a floating card to meet someone new.</li>
                        <li>Tap a card to read their story and traits.</li>
                        <li>Hit “View in AR” to drop them into your world.</li>
                    </ul>
                </div>
            </div>
            <div class="hero-search">
                <label class="sr-only" for="search-input">Search characters</label>
                <div class="search-container">
                    <input type="text" id="search-input" placeholder="SEARCH NAME" autocomplete="off" />
                    <button id="search-btn" class="search-btn">&#128269;</button>
                </div>
            </div>
            <div class="hero-scroll-cta">
                <button type="button" id="scrollToGallery">↓ Scroll to see the gallery</button>
            </div>
            <div class="hero-tips-panel" id="heroTipsPanel" aria-live="polite">
                <strong>AR READY CHECK</strong>
                <p>Find a clear floor, brighten your room, and move your phone slowly so Scene Viewer or Quick Look can
                    lock onto the space.</p>
            </div>
        </div>
    </header>

    <main id="gallery-container"></main>
    <footer class="footer-section"></footer>

    <!-- back to top -->
    <button id="backToTop" class="back-to-top">↑</button>

    <!-- AR Modal -->
    <!-- AR Modal (enhanced UI) -->
    <div id="arModal" class="ar-modal" aria-hidden="true">
        <div class="ar-wrap">
            <!-- Top bar -->
            <div class="ar-topbar">
                <h3 id="arTitle">Character</h3>
                <button class="ar-close" id="arClose" aria-label="Close">✕</button>
            </div>

            <!-- 3D viewer -->
            <model-viewer id="arMV" src="./assets/ar/animationtemplate.glb"
                ios-src="./functions/template/animationtemplate.usdz" ar ar-modes="webxr scene-viewer quick-look"
                placement="floor" camera-controls shadow-intensity="0.25" exposure="1" tone-mapping="aces"
                environment-image="neutral" interaction-prompt="none" autoplay animation-loop>
            </model-viewer>


            <div class="ar-help" id="arHelpPanel">
                <div class="ar-preview">
                    <img id="arPreviewImg" src="./assets/wave-home-1.png" alt="Character preview thumbnail">
                </div>
                <div class="ar-status-block">
                    <span class="ar-status-chip" id="arStatusChip" data-state="idle">Idle</span>
                    <p id="arStatusText">Pick a card and tap “View in AR”.</p>
                </div>
                <ol class="ar-checklist">
                    <li><span>1</span>Tap the cube icon or “Open in AR”.</li>
                    <li><span>2</span>Move your phone slowly to find the floor.</li>
                    <li><span>3</span>Tap once to place your neighbour.</li>
                </ol>
                <div class="ar-device-note">
                    <p><strong>Android:</strong> Scene Viewer launches in a sheet.</p>
                    <p><strong>iOS:</strong> Quick Look opens with your textures.</p>
                </div>
                <button class="ar-launch" id="arLaunchBtn" type="button" disabled>Open in AR</button>
            </div>

        </div>
    </div>

    <!-- 1) Firebase init -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-app.js";
        import { getFirestore, collection, query, orderBy, getDocs }
            from "https://www.gstatic.com/firebasejs/12.0.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDwpNjnDFAA_5P64zMOt-GTSOdETx2xKJQ",
            authDomain: "people-of-pdd-website.firebaseapp.com",
            projectId: "people-of-pdd-website",
            storageBucket: "people-of-pdd-website.firebasestorage.app",
            messagingSenderId: "685048567158",
            appId: "1:685048567158:web:abc51754b5b785219c1657",
            measurementId: "G-1VRMYRMXKN"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // expose for non-module scripts
        window.db = db;
        window.collection = collection;
        window.query = query;
        window.orderBy = orderBy;
        window.getDocs = getDocs;
    </script>

    <script>
        const API_BASE =
            "https://asia-southeast1-people-of-pdd-website.cloudfunctions.net/api";

        async function makeUsdzFromPng({ posterDataUrl, traitDataUrls = [], nameDataUrl, pngDataUrl, pngUrl, displayName, traits = [] }) {
            const payload = { displayName };
            if (posterDataUrl || pngDataUrl) payload.posterDataUrl = posterDataUrl || pngDataUrl;
            if (pngUrl) payload.pngUrl = pngUrl;
            if (Array.isArray(traitDataUrls) && traitDataUrls.length) payload.traitDataUrls = traitDataUrls;
            if (nameDataUrl) payload.nameDataUrl = nameDataUrl;
            if (Array.isArray(traits) && traits.length) {
                payload.traits = traits
                    .map(t => typeof t === 'string' ? t.trim() : '')
                    .filter(Boolean);
            }
            const resp = await fetch(`${API_BASE}/make-usdz`, {
                method: "POST",
                headers: { "content-type": "application/json" },
                body: JSON.stringify(payload),
            });
            const j = await resp.json();
            if (!resp.ok || !j.ok) throw new Error(j.error || "usdz build failed");

            console.log("USDZ URL (from makeUsdzFromPng):", j.usdzUrl); // << add this
            window.lastUsdz = j.usdzUrl; // handy to grab in console later
            window.lastTemplateVariant = j.templateVariant || 'oldSchool';
            return {
                usdzUrl: j.usdzUrl,
                templateVariant: j.templateVariant || 'oldSchool'
            };
        }

    </script>


    <!-- 2) Back-to-top + tiny helpers -->
    <script>
        const backToTop = document.getElementById('backToTop');
        backToTop.addEventListener('click', () => window.scrollTo({ top: 0, behavior: 'smooth' }));
        window.addEventListener('scroll', () => {
            const on = window.scrollY > 200;
            backToTop.style.opacity = on ? '1' : '0';
            backToTop.style.pointerEvents = on ? 'auto' : 'none';
        });

        function goBack() { window.location.href = 'index.html'; }
    </script>

    <!-- 3) Gallery rendering + tooltip + "view in ar" + PNG compositor -->
    <script>
        const heroEl = document.querySelector('.hero');
        const heroDesktopMq = window.matchMedia('(min-width: 901px)');
        const HERO_CONDENSE_SCROLL = 160;
        const HERO_RELAX_SCROLL = 80;
        let heroIsCondensed = false;
        const heroTipsToggle = document.getElementById('arTipsToggle');
        const heroTipsPanel = document.getElementById('heroTipsPanel');
        heroTipsToggle?.addEventListener('click', () => {
            if (!heroTipsPanel) return;
            const open = heroTipsPanel.classList.toggle('open');
            heroTipsToggle.textContent = open ? 'Hide AR tips ×' : 'View AR tips →';
        });

        const scrollCtaBtn = document.getElementById('scrollToGallery');
        scrollCtaBtn?.addEventListener('click', () => {
            document.getElementById('gallery-container')?.scrollIntoView({ behavior: 'smooth' });
        });

        function setHeroCondensed(next) {
            if (heroIsCondensed === next) return;
            heroIsCondensed = next;
            heroEl.classList.toggle('is-condensed', next);
            heroEl.classList.toggle('is-muted', next);
        }

        function updateHeroCondensed() {
            if (!heroEl) return;
            const isDesktop = heroDesktopMq.matches;
            if (!isDesktop) {
                setHeroCondensed(false);
                return;
            }
            const y = window.scrollY;
            if (!heroIsCondensed && y > HERO_CONDENSE_SCROLL) {
                setHeroCondensed(true);
            } else if (heroIsCondensed && y < HERO_RELAX_SCROLL) {
                setHeroCondensed(false);
            }
        }


        window.addEventListener('scroll', updateHeroCondensed);
        window.addEventListener('resize', updateHeroCondensed);
        if (typeof heroDesktopMq.addEventListener === 'function') {
            heroDesktopMq.addEventListener('change', updateHeroCondensed);
        } else if (typeof heroDesktopMq.addListener === 'function') {
            heroDesktopMq.addListener(updateHeroCondensed);
        }
        updateHeroCondensed();

        const heroStatEls = {
            total: document.getElementById('statTotal')
        };

        function updateHeroStats({ total = 0 } = {}) {
            if (heroStatEls.total) heroStatEls.total.textContent = total.toString();
        }

        const arUi = (() => {
            const statusChip = document.getElementById('arStatusChip');
            const statusText = document.getElementById('arStatusText');
            const previewImg = document.getElementById('arPreviewImg');
            const launchBtn = document.getElementById('arLaunchBtn');
            const fallbackPreview = './assets/wave-home-1.png';

            const setStatus = (state = 'idle', message = 'Pick a card and tap “View in AR”.') => {
                if (statusChip) {
                    statusChip.dataset.state = state;
                    const label = { idle: 'Idle', building: 'Preparing', ready: 'Ready', error: 'Error' }[state] || state;
                    statusChip.textContent = label;
                }
                if (statusText) statusText.textContent = message;
                if (launchBtn) {
                    if (state === 'ready') launchBtn.removeAttribute('disabled');
                    else launchBtn.setAttribute('disabled', 'disabled');
                }
            };

            const setPreview = (src) => {
                if (!previewImg) return;
                previewImg.src = src || fallbackPreview;
            };

            setPreview();
            setStatus('idle');

            return { setStatus, setPreview, launchBtn };
        })();

        window.__arUi = arUi;

        arUi.launchBtn?.addEventListener('click', async () => {
            const mv = document.getElementById('arMV');
            if (!mv) return;
            try {
                arUi.setStatus('ready', 'Attempting to open AR…');
                if (typeof mv.activateAR === 'function') {
                    await mv.activateAR();
                } else if (typeof mv.enterAR === 'function') {
                    await mv.enterAR();
                } else {
                    alert('Use the cube button in the viewer to open AR on this device.');
                }
                arUi.setStatus('ready', 'If nothing happens, tap the cube icon inside the viewer.');
            } catch (err) {
                console.error('activateAR failed', err);
                arUi.setStatus('ready', 'Open AR via the cube button if this shortcut does not work.');
            }
        });

        // layout constants
        const CARD_W = 200 / 1.5;
        const CARD_H = 360 / 1.5;
        const container = document.getElementById('gallery-container');
        const headerEl = document.querySelector('header');
        const footerEl = document.querySelector('footer');
        let SCALE = 1;

        let hairHatTraits = {};
        let torsoTraits = {};
        let legsTraits = {};
        let shoesTraits = {};
        let keywordIndexMap = {};
        const badgeCache = new Map();
        let traitInitPromise = null;

        function csvToMap(text) {
            const lines = text.trim().split(/\r?\n/);
            const header = lines.shift().split(',');
            const fi = header.findIndex(h => /filename/i.test(h));
            const ti = header.findIndex(h => /trait/i.test(h));
            const map = {};
            for (const line of lines) {
                if (!line.trim()) continue;
                const cols = line.split(',');
                const file = cols[fi]?.trim();
                const trait = cols[ti]?.trim();
                if (file && trait) map[file] = trait;
            }
            return map;
        }

        function csvToKeywordIndex(text) {
            const lines = text.trim().split(/\r?\n/);
            const header = lines.shift().split(',');
            const ki = header.findIndex(h => /keyword/i.test(h));
            const ii = header.findIndex(h => /(image\s*number|number|index)/i.test(h));
            const map = {};
            for (const line of lines) {
                if (!line.trim()) continue;
                const cols = line.split(',');
                const kw = (cols[ki] || '').trim().toLowerCase();
                const num = parseInt((cols[ii] || '').trim(), 10);
                if (kw && Number.isFinite(num)) map[kw] = num;
            }
            return map;
        }

        async function ensureTraitsReady() {
            if (!traitInitPromise) {
                traitInitPromise = (async () => {
                    const [
                        hairCSV,
                        torsoCSV,
                        legsCSV,
                        shoesCSV,
                        keywordCSV
                    ] = await Promise.all([
                        fetch('./assets/traits/hair-hat.csv').then(r => r.text()),
                        fetch('./assets/traits/torso.csv').then(r => r.text()),
                        fetch('./assets/traits/legs.csv').then(r => r.text()),
                        fetch('./assets/traits/shoes.csv').then(r => r.text()),
                        fetch('./assets/traits/pdd_keywords.csv').then(r => r.text())
                    ]);
                    hairHatTraits = csvToMap(hairCSV);
                    torsoTraits = csvToMap(torsoCSV);
                    legsTraits = csvToMap(legsCSV);
                    shoesTraits = csvToMap(shoesCSV);
                    keywordIndexMap = csvToKeywordIndex(keywordCSV);
                })().catch(err => {
                    traitInitPromise = null;
                    console.error('failed to load trait data', err);
                    throw err;
                });
            }
            return traitInitPromise;
        }

        function dedupeEntries(entries) {
            const seen = new Set();
            return entries.map(entry => {
                const value = (entry.text || '').trim();
                if (!value || seen.has(value)) return { ...entry, text: '' };
                seen.add(value);
                return entry;
            });
        }

        function badgeUrlFromTrait(trait) {
            const idx = keywordIndexMap[(trait || '').trim().toLowerCase()];
            if (!idx) return null;
            return `./assets/traits/badges/${idx}.svg`;
        }

        function loadBadgeImage(url) {
            if (!url) return Promise.resolve(null);
            if (badgeCache.has(url)) return Promise.resolve(badgeCache.get(url));
            return new Promise(resolve => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    badgeCache.set(url, img);
                    resolve(img);
                };
                img.onerror = () => resolve(null);
                img.src = url;
            });
        }

        const ensureSemiBoldFont = (() => {
            let promise = null;
            return () => {
                if (promise) return promise;
                if (!('fonts' in document) || !window.FontFace) {
                    return Promise.resolve(null);
                }
                const face = new FontFace('PP Mori SemiBold', 'url("./assets/fonts/PPMori-SemiBold.otf")');
                promise = face.load()
                    .then(loaded => {
                        document.fonts.add(loaded);
                        return loaded;
                    })
                    .catch(err => {
                        console.warn('Failed to load PP Mori SemiBold font', err);
                        promise = null;
                        return null;
                    });
                return promise;
            };
        })();

        const TRAIT_TEXTURE_SIZE = 1024;
        const NAME_TEXTURE_W = 1010;
        const NAME_TEXTURE_H = 256;

        function buildTraitTexture(entry, badgeImg) {
            const label = (entry?.text || '').trim();
            const hasContent = badgeImg || label;
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = TRAIT_TEXTURE_SIZE;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, TRAIT_TEXTURE_SIZE, TRAIT_TEXTURE_SIZE);

            if (!hasContent) {
                return canvas.toDataURL('image/png');
            }

            const fg = (entry?.color || '#2a9df4').trim() || '#2a9df4';

            if (badgeImg) {
                const maxDim = TRAIT_TEXTURE_SIZE * 0.62;
                const aspect = badgeImg.naturalWidth / (badgeImg.naturalHeight || 1);
                let drawW = maxDim;
                let drawH = maxDim;
                if (aspect >= 1) {
                    drawH = maxDim / aspect;
                } else {
                    drawW = maxDim * aspect;
                }
                const dx = (TRAIT_TEXTURE_SIZE - drawW) / 2;
                const dy = (TRAIT_TEXTURE_SIZE - drawH) / 2;
                ctx.drawImage(badgeImg, dx, dy, drawW, drawH);
            } else if (label) {
                let fontSize = 128;
                const maxWidth = TRAIT_TEXTURE_SIZE * 0.68;
                const maxLines = 3;
                const upper = label.toUpperCase();
                let lines = [];

                const measureLines = () => {
                    const words = upper.split(/\s+/);
                    const tmp = [];
                    let current = '';
                    for (const word of words) {
                        const candidate = current ? `${current} ${word}` : word;
                        if (!current || ctx.measureText(candidate).width <= maxWidth) {
                            current = candidate;
                        } else {
                            tmp.push(current);
                            current = word;
                        }
                    }
                    if (current) tmp.push(current);
                    return tmp;
                };

                while (fontSize >= 40) {
                    ctx.font = `800 ${fontSize}px 'PP Mori', 'Helvetica Neue', Arial, sans-serif`;
                    lines = measureLines();
                    const fitsWidth = lines.every(line => ctx.measureText(line).width <= maxWidth);
                    if (lines.length <= maxLines && fitsWidth) break;
                    fontSize -= 6;
                }
                if (!lines.length) lines = [upper];

                ctx.fillStyle = fg;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0,0,0,0.45)';
                ctx.shadowBlur = 18;
                ctx.shadowOffsetY = 6;
                const lineHeight = fontSize * 1.1;
                const startY = TRAIT_TEXTURE_SIZE / 2 - ((lines.length - 1) * lineHeight) / 2;
                lines.forEach((line, i) => {
                    const y = startY + i * lineHeight;
                    ctx.fillText(line, TRAIT_TEXTURE_SIZE / 2, y);
                });
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetY = 0;
            }

            return canvas.toDataURL('image/png');
        }

        // responsive scale
        const isMobileView = () => window.matchMedia('(max-width: 600px)').matches;
        const currentScale = () => isMobileView() ? 0.72 : 1;
        function resizeContainer() {
            const headerHeight = headerEl?.offsetHeight || 0;
            const footerHeight = footerEl?.offsetHeight || 0;
            const available = window.innerHeight - headerHeight - footerHeight;
            const minHeight = isMobileView() ? window.innerHeight * 0.65 : 320;
            const targetHeight = Math.max(available, minHeight);
            container.style.height = `${targetHeight}px`;
            container.style.minHeight = `${Math.max(targetHeight, 320)}px`;
            SCALE = currentScale();
        }
        window.addEventListener('resize', resizeContainer);

        // init — fetch from Firestore and render
        document.addEventListener('DOMContentLoaded', async () => {
            resizeContainer();
            await ensureTraitsReady();

            const q = window.query(window.collection(window.db, "galleryCharacters"), window.orderBy("createdAt", "desc"));
            const snap = await window.getDocs(q);

            let i = 0;
            const stats = { total: 0 };

            snap.forEach(doc => {
                const d = doc.data();
                stats.total += 1;
                renderAvatar(
                    { selections: d.selections, faceData: d.faceUrl, name: d.name, favThing: d.favThing },
                    i++,
                    SCALE
                );
            });

            updateHeroStats(stats);
            brickLayout();

            // reflow on resize
            window.addEventListener('resize', () => {
                resizeContainer();
                document.querySelectorAll('.gallery-card').forEach(card => {
                    card.dataset.scale = SCALE;
                    card.style.transform = `scale(${SCALE})`;
                });
                brickLayout();
            });

            // live search
            document.getElementById('search-input')?.addEventListener('input', filterGallery);
            document.getElementById('search-btn')?.addEventListener('click', filterGallery);
        });

        // ---- render each avatar card ----
        function renderAvatar({ selections = [], faceData, name, favThing }, index, scale = 1) {
            const wrapper = document.createElement('div');
            wrapper.classList.add('gallery-card');
            wrapper.dataset.name = (name || '').trim().toLowerCase();
            wrapper.dataset.scale = scale;
            wrapper.dataset.selections = JSON.stringify(selections || []);
            wrapper.dataset.face = faceData || '';

            wrapper.style.width = CARD_W + 'px';
            wrapper.style.height = CARD_H + 'px';
            wrapper.style.transform = `scale(${scale})`;

            const svgNS = 'http://www.w3.org/2000/svg';
            const svg = document.createElementNS(svgNS, 'svg');
            svg.setAttribute('viewBox', `0 0 ${CARD_W} ${CARD_H}`);
            svg.setAttribute('preserveAspectRatio', 'xMidYMid slice');
            svg.setAttribute('width', CARD_W);
            svg.setAttribute('height', CARD_H);
            svg.style.position = 'absolute';
            svg.style.left = '0';
            svg.style.top = '0';
            svg.style.zIndex = '1';

            const group = document.createElementNS(svgNS, 'g');
            group.setAttribute('transform', `translate(${CARD_W / 2}, 10)`);

            // colorful base shape
            const baseShape = createBaseShape(svgNS, CARD_W);
            baseShape.setAttribute('transform', (baseShape.getAttribute('transform') || '') + ' translate(0, 20)');
            group.appendChild(baseShape);

            // simple rig
            const baseRig = {
                head: { x: 0, y: 20 },
                shoulderL: { x: -40, y: 20 }, shoulderR: { x: 40, y: 20 },
                hipL: { x: 0, y: 75 }, hipR: { x: 0, y: 75 },
                kneeL: { x: 0, y: 140 }, kneeR: { x: 0, y: 140 },
                footL: { x: 0, y: 180 }, footR: { x: 0, y: 180 }
            };
            const centers = [
                { ctr: baseRig.footL, size: 80 },   // shoes
                { ctr: baseRig.kneeL, size: 100 },  // legs
                { ctr: baseRig.hipL, size: 90 },   // torso
                { ctr: baseRig.head, size: 60 }    // head
            ];

            // draw 4 parts (reverse-index like your original)
            centers.forEach((cfg, i) => {
                const img = document.createElementNS(svgNS, 'image');
                img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', selections[3 - i]);
                img.setAttribute('width', cfg.size);
                img.setAttribute('height', cfg.size);
                img.setAttribute('x', cfg.ctr.x - cfg.size / 2);
                img.setAttribute('y', cfg.ctr.y - cfg.size / 2);
                group.appendChild(img);
            });

            svg.appendChild(group);
            wrapper.appendChild(svg);

            // face overlay if present
            if (isRenderableImage(faceData)) {
                const headCfg = centers[3];
                const offsetX = CARD_W / 2 + headCfg.ctr.x - headCfg.size / 2;
                const offsetY = 5 + headCfg.ctr.y - headCfg.size / 2;

                loadImageSafe(faceData).then((img) => {
                    if (!img) return;
                    img.width = headCfg.size; img.height = headCfg.size;
                    img.style.position = 'absolute';
                    img.style.left = `${offsetX}px`;
                    img.style.top = `${offsetY}px`;
                    img.style.zIndex = '2';
                    wrapper.style.zIndex = '3';
                    wrapper.appendChild(img);
                });
            }

            // tooltip (with AR button)
            const tooltip = document.createElement('div');
            tooltip.classList.add('tooltip');
            tooltip.innerHTML = `
      <h3>${(name || '').toUpperCase()}</h3>
      <p>My favourite thing to do in Punggol:
        <b style="color:#fff;">${favThing ? `${favThing}!` : ''}</b>
      </p>
      <button class="ar-btn" type="button">view in ar</button>
    `;
            wrapper.appendChild(tooltip);

            // toggle tooltip on card click
            wrapper.addEventListener('click', (e) => {
                if (e.target.closest('.ar-btn')) return; // AR handled below
                e.stopPropagation();
                document.querySelectorAll('.gallery-card.show-tip').forEach(c => {
                    if (c !== wrapper) { c.classList.remove('show-tip'); c.style.zIndex = ''; }
                });
                const open = wrapper.classList.toggle('show-tip');
                wrapper.style.zIndex = open ? '9999' : '';
            });
            // close when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.gallery-card')) {
                    document.querySelectorAll('.gallery-card.show-tip').forEach(c => { c.classList.remove('show-tip'); c.style.zIndex = ''; });
                }
            });

            // “view in AR” → compose textures → open modal
            tooltip.querySelector('.ar-btn').addEventListener('click', async (e) => {
                e.stopPropagation();

                const sels = JSON.parse(wrapper.dataset.selections || '[]');
                const face = wrapper.dataset.face || '';
                const displayName = (name || '').trim() || 'Your Character';

                window.__arUi?.setStatus('building', 'Composing textures…');
                const textures = await composeAvatarPNG(sels, face, displayName);
                if (!textures || !textures.posterDataUrl) {
                    window.__arUi?.setStatus('error', 'Could not compose AR textures. Please try again.');
                    alert('Could not compose AR textures (CORS).');
                    return;
                }
                window.lastArTextures = textures;
                window.__arUi?.setPreview(textures.posterDataUrl);

                // SAFER: btn may be null if handler bound oddly or DOM moved
                const btn = (e.currentTarget && e.currentTarget.nodeType === 1)
                    ? e.currentTarget
                    : e.target.closest('.ar-btn');

                const prevLabel = btn ? btn.textContent : null;
                if (btn) { btn.textContent = 'preparing…'; btn.disabled = true; }

                try {
                    window.__arUi?.setStatus('building', 'Packaging for AR…');
                    const { usdzUrl, templateVariant } = await makeUsdzFromPng({
                        posterDataUrl: textures.posterDataUrl,
                        traitDataUrls: textures.traitDataUrls,
                        nameDataUrl: textures.nameDataUrl,
                        displayName,
                        traits: textures.traits
                    });
                    console.log("USDZ URL (from click):", usdzUrl);
                    window.lastUsdz = usdzUrl; // optional
                    window.lastTemplateVariant = templateVariant;


                    const mv = document.getElementById('arMV');
                    if (!mv) throw new Error('#arMV not found');
                    mv.setAttribute('ios-src', usdzUrl + '&v=' + Date.now());

                    // open modal + set runtime texture (Android/WebXR path)
                    textures.templateVariant = templateVariant;
                    window.openARWithTexture?.(textures, displayName);

                    window.__arUi?.setStatus('ready', 'Tap “Open in AR” or the cube icon to place them.');

                    // iOS quick look (ignore errors if not supported)
                    if (/iphone|ipad|ipod/i.test(navigator.userAgent)) {
                        try { await mv.activateAR(); } catch { }
                    }
                } catch (err) {
                    console.error(err);
                    alert('AR package error: ' + err.message);
                    window.__arUi?.setStatus('error', 'Could not build the AR package. Please try again.');
                } finally {
                    if (btn) { btn.textContent = prevLabel; btn.disabled = false; }
                }
            });

            container.appendChild(wrapper);
        }

        // ---- helpers & layout ----
        function loadImageSafe(src, timeout = 6000) {
            return new Promise((resolve) => {
                const img = new Image();
                let doneOnce = false;
                const done = ok => { if (!doneOnce) { doneOnce = true; resolve(ok ? img : null); } };
                const t = setTimeout(() => done(false), timeout);
                img.onload = () => { clearTimeout(t); done(true); };
                img.onerror = () => { clearTimeout(t); done(false); };
                img.src = src;
            });
        }

        function isRenderableImage(src) {
            if (!src || typeof src !== 'string') return false;
            const s = src.trim();
            if (s.startsWith('data:text/')) return false;
            if (s.startsWith('data:image/')) return true;
            if (s.startsWith('blob:')) return true;
            try {
                const u = new URL(s, location.href);
                const okProto = u.protocol === 'http:' || u.protocol === 'https:';
                const p = u.pathname.toLowerCase();
                const okExt = p.endsWith('.png') || p.endsWith('.jpg') || p.endsWith('.jpeg') || p.endsWith('.webp');
                return okProto && okExt;
            } catch { return false; }
        }

        function filterGallery() {
            const term = document.getElementById('search-input').value.trim().toLowerCase();
            const cards = Array.from(document.querySelectorAll('.gallery-card'));
            if (!term) { cards.forEach(c => c.style.display = ''); brickLayout(); return; }
            const matching = [], nonMatching = [];
            cards.forEach(card => {
                if (card.dataset.name.includes(term)) { matching.push(card); card.style.display = ''; }
                else { nonMatching.push(card); card.style.display = 'none'; }
            });
            container.innerHTML = '';
            [...matching, ...nonMatching].forEach(card => container.appendChild(card));
            brickLayout();
        }

        function brickLayout() {
            const cards = Array.from(document.querySelectorAll('.gallery-card'));
            if (!cards.length) return;

            const baseW = CARD_W, baseH = CARD_H;
            const containerWidth = container.clientWidth;
            const mobile = isMobileView();
            const margin = mobile ? 30 : 100;
            const scale = currentScale();
            const gapX = mobile ? 100 : Math.max(24, container.clientWidth / 9);
            const gapY = mobile ? 8 : 60;

            const usableWidth = containerWidth - 2 * margin;
            const effW = baseW * scale, effH = baseH * scale;
            const maxCardsPerRow = Math.max(1, Math.floor((usableWidth + gapX) / (effW + gapX)));

            let x = 0, y = 0, row = 0, col = 0;

            cards.forEach((card) => {
                if (parseFloat(card.dataset.scale || '1') !== scale) {
                    card.dataset.scale = scale;
                    card.style.transform = `scale(${scale})`;
                }
                const offsetX = (row % 2 === 0) ? 0 : (effW / 2 + gapX / 2);
                card.style.left = `${margin + x + offsetX}px`;
                card.style.top = `${margin + y}px`;

                col++; x += effW + gapX;

                const nextWouldOverflow = (margin + x + effW + offsetX > containerWidth - margin);
                if (col >= maxCardsPerRow || nextWouldOverflow) {
                    row++; col = 0; x = 0; y += effH + gapY;
                }
            });

            const totalHeight = margin + y + effH + gapY + 8;
            container.style.minHeight = `${Math.max(totalHeight, parseFloat(container.style.height) || 0)}px`;
        }

        function createBaseShape(svgNS) {
            const shapes = [
                { type: 'ellipse', cx: 68.41, cy: 28.33, rx: 53.5, ry: 16.59 },
                { type: 'path', d: 'M101.97,31.92l-35.5,17.77c-5.41,2.71-11.77,2.77-17.24.17L11.98,32.14c-3.41-1.62-3.41-6.48,0-8.1L48.4,6.69c5.31-2.53,11.47-2.55,16.79-.05l36.67,17.2c3.39,1.59,3.46,6.4.1,8.08Z' },
                { type: 'path', d: 'M94.9,36l4.47,8.76c2.07,4.04-8.4,7.25-17.15,5.25l-18.94-4.34c-1.52-.35-3.38-.34-4.9.03l-18.85,4.55c-8.7,2.11-19.24-1-17.26-5.1l4.28-8.86c.34-.71-.24-1.44-1.53-1.93l-16.12-6.02c-7.44-2.79-3.49-7.93,6.48-8.43l21.59-1.07c1.73-.09,3.24-.54,3.95-1.2l8.88-8.23c4.1-3.79,17.08-3.82,21.27-.04l9.06,8.16c.73.66,2.24,1.1,3.97,1.18l21.61.93c9.98.43,14.04,5.5,6.66,8.32l-15.99,6.1c-1.29.49-1.85,1.22-1.49,1.93Z' }
            ];
            const colors = ['#9e005d', '#3fa9f5', '#22b573', '#e85e24', '#f7931e'];
            const s = shapes[Math.floor(Math.random() * shapes.length)];
            const color = colors[Math.floor(Math.random() * colors.length)];
            const el = document.createElementNS(svgNS, s.type);
            el.setAttribute('fill', color);
            if (s.type === 'ellipse') { el.setAttribute('cx', 0); el.setAttribute('cy', 180); el.setAttribute('rx', s.rx); el.setAttribute('ry', s.ry); }
            else { el.setAttribute('d', s.d); el.setAttribute('transform', 'translate(-60, 150)'); }
            return el;
        }




        // ---- PNG compositor (exact placement + NAME BANNER) ----
        async function composeAvatarPNG(selections, faceData, displayName = '') {
            await ensureTraitsReady();
            // canvas & VB from your original exporter
            const CANVAS_W = 1200, CANVAS_H = 1800;
            const vbW = 800, vbH = 800;

            const baseScale = CANVAS_W / vbW;
            const fillMultiplier = 2.35;
            const s = baseScale * fillMultiplier;
            const xOff = (CANVAS_W - vbW * s) / 2;
            const baseYOff = (CANVAS_H - vbH * s) / 2;
            const manualYOffset = 720;
            const yOff = baseYOff + manualYOffset;

            const originVB = { x: vbW / 2, y: 100 };
            const baseRig = {
                shoulderL: { x: -40, y: 20 }, shoulderR: { x: 40, y: 20 },
                hipL: { x: 0, y: 75 }, hipR: { x: 0, y: 75 },
                kneeL: { x: 0, y: 140 }, kneeR: { x: 0, y: 140 },
                footL: { x: 0, y: 180 }, footR: { x: 0, y: 180 }
            };
            const headVB = { x: originVB.x, y: originVB.y };
            const torsoVB = {
                x: originVB.x + (baseRig.shoulderL.x + baseRig.shoulderR.x + baseRig.hipL.x + baseRig.hipR.x) / 4,
                y: originVB.y + (baseRig.shoulderL.y + baseRig.shoulderR.y + baseRig.hipL.y + baseRig.hipR.y) / 4 + 10
            };
            const legsVB = {
                x: originVB.x + (baseRig.kneeL.x + baseRig.kneeR.x) / 2,
                y: originVB.y + (baseRig.kneeL.y + baseRig.kneeR.y) / 2 + 20
            };
            const shoesVB = {
                x: originVB.x + (baseRig.footL.x + baseRig.footR.x) / 2,
                y: originVB.y + (baseRig.footL.y + baseRig.footR.y) / 2 + 40
            };

            // render order and max sizes — identical to your PNG exporter
            const centersVB = [shoesVB, legsVB, torsoVB, headVB];
            const liSizesVB = [180, 200, 200, 130];

            const imgs = await Promise.all(
                (selections || []).map(u => new Promise(res => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => res(img);
                    img.onerror = () => res(null);
                    img.src = u;
                }))
            );

            const out = document.createElement('canvas');
            out.width = CANVAS_W; out.height = CANVAS_H;
            const ctx = out.getContext('2d');

            // 1) avatar parts (unchanged logic, small comments)
            for (let i = 0; i < 4; i++) {
                const img = imgs[3 - i]; if (!img) continue;

                const maxVB = liSizesVB[i];
                const aspect = img.naturalWidth / img.naturalHeight;

                let partVBW, partVBH;
                if (aspect >= 1) { partVBW = maxVB; partVBH = maxVB / aspect; }
                else { partVBH = maxVB; partVBW = maxVB * aspect; }

                let extraScale = 1;
                if (i === 0) extraScale = 0.95;  // shoes
                if (i === 1) extraScale = 1.08;  // legs
                if (i === 3) extraScale = 0.90;  // head

                const pxW = partVBW * s * extraScale;
                const pxH = partVBH * s * extraScale;

                const ctrVB = [shoesVB, legsVB, torsoVB, headVB][i];
                const baseX = ctrVB.x * s - pxW / 2 + xOff;
                let baseY = ctrVB.y * s - pxH / 2 + yOff;

                // tiny per-slot offsets — as in your exporter
                if (i === 3) baseY -= 120;  // head up a bit
                if (i === 2) baseY += 50;   // legs down a bit
                if (i === 1) baseY += 200;  // torso up
                if (i === 0) baseY += 300;  // shoes up

                ctx.drawImage(img, baseX, baseY, pxW, pxH);
            }

            // 2) face overlay (unchanged)
            if (faceData && (faceData.startsWith('data:') || faceData.startsWith('http') || faceData.startsWith('blob:'))) {
                const face = await new Promise(res => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => res(img);
                    img.onerror = () => res(null);
                    img.src = faceData;
                });
                if (face) {
                    const manualYAdjust = -25 - 120;
                    const fcW = face.naturalWidth, fcH = face.naturalHeight;
                    const headCtr = headVB;
                    const xF = headCtr.x * s - (fcW * s) / 2 + xOff;
                    const yF = headCtr.y * s - (fcH * s) / 2 + yOff + manualYAdjust;
                    ctx.drawImage(face, 0, 0, fcW, fcH, xF, yF, fcW * s, fcH * s);
                }
            }

            const parts = Array.isArray(selections) ? selections : [];
            const getFileName = (idx) => {
                const src = typeof parts[idx] === 'string' ? parts[idx] : '';
                if (!src) return '';
                const segment = (src.split('/').pop() || '');
                const clean = segment.split('?')[0].split('#')[0];
                let decoded = clean;
                try {
                    decoded = decodeURIComponent(clean);
                } catch { /* ignore */ }
                const finalSeg = decoded.includes('/') ? decoded.split('/').pop() : decoded;
                return (finalSeg || '').trim();
            };

            const hatFile = getFileName(0);
            const torsoFile = getFileName(1);
            const legsFile = getFileName(2);
            const shoesFile = getFileName(3);

            const traitEntries = [
                { text: hairHatTraits[hatFile] || '', color: '#22b573' },
                { text: torsoTraits[torsoFile] || '', color: '#e91e63' },
                { text: legsTraits[legsFile] || '', color: '#f4b63d' },
                { text: shoesTraits[shoesFile] || '', color: '#2a9df4' }
            ];
            const traitLabels = traitEntries
                .map(entry => (entry.text || '').trim())
                .filter(label => !!label);

            const badgeImgs = await Promise.all(traitEntries.map(entry => {
                const badgeUrl = entry.text ? badgeUrlFromTrait(entry.text) : null;
                return badgeUrl ? loadBadgeImage(badgeUrl) : Promise.resolve(null);
            }));

            const traitDataUrls = traitEntries.map((entry, idx) => buildTraitTexture(entry, badgeImgs[idx]));

            let posterDataUrl = null;
            try {
                posterDataUrl = out.toDataURL('image/png'); // transparent PNG for avatar plane
            } catch (e) {
                console.error('toDataURL failed (likely CORS/tainted canvas):', e);
                return null;
            }

            let nameDataUrl = null;
            try {
                const nameCanvas = document.createElement('canvas');
                nameCanvas.width = NAME_TEXTURE_W;
                nameCanvas.height = NAME_TEXTURE_H;
                const nameCtx = nameCanvas.getContext('2d');
                nameCtx.clearRect(0, 0, NAME_TEXTURE_W, NAME_TEXTURE_H);
                if (displayName) {
                    const text = String(displayName).trim();
                    if (text) {
                        await ensureSemiBoldFont();
                        const upper = text.toUpperCase();
                        const maxWidth = NAME_TEXTURE_W * 0.82;
                        const maxLines = 2;
                        let fontSize = 88;
                        let lines = [];
                        const measureLines = () => {
                            const words = upper.split(/\s+/);
                            const tmp = [];
                            let current = '';
                            for (const word of words) {
                                const candidate = current ? `${current} ${word}` : word;
                                if (!current || nameCtx.measureText(candidate).width <= maxWidth) {
                                    current = candidate;
                                } else {
                                    tmp.push(current);
                                    current = word;
                                }
                            }
                            if (current) tmp.push(current);
                            return tmp;
                        };

                        while (fontSize >= 56) {
                            nameCtx.font = `800 ${fontSize}px 'PP Mori SemiBold', 'PP Mori', 'Helvetica Neue', Arial, sans-serif`;
                            lines = measureLines();
                            const fitsWidth = lines.every(line => nameCtx.measureText(line).width <= maxWidth);
                            if (lines.length <= maxLines && fitsWidth) break;
                            fontSize -= 6;
                        }
                        if (!lines.length) lines = [upper];

                        nameCtx.textAlign = 'center';
                        nameCtx.textBaseline = 'middle';
                        nameCtx.font = `800 ${fontSize}px 'PP Mori SemiBold', 'PP Mori', 'Helvetica Neue', Arial, sans-serif`;

                        const lineHeight = fontSize * 1.05;
                        const maxLineWidth = lines.reduce((m, line) => Math.max(m, nameCtx.measureText(line).width), 0);
                        const padX = Math.max(NAME_TEXTURE_W * 0.12, 54);
                        const padY = Math.max(NAME_TEXTURE_H * 0.14, 40);
                        const totalTextHeight = lines.length * lineHeight;
                        const rectWidth = Math.min(NAME_TEXTURE_W - 40, maxLineWidth + padX * 2);
                        const rectHeight = Math.min(NAME_TEXTURE_H - 40, totalTextHeight + padY * 2);
                        const rectX = (NAME_TEXTURE_W - rectWidth) / 2;
                        const rectY = (NAME_TEXTURE_H - rectHeight) / 2;
                        const cornerR = Math.min(96, rectHeight / 1.6);

                        const drawRoundedRect = (ctx, x, y, w, h, r) => {
                            ctx.beginPath();
                            ctx.moveTo(x + r, y);
                            ctx.lineTo(x + w - r, y);
                            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                            ctx.lineTo(x + w, y + h - r);
                            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                            ctx.lineTo(x + r, y + h);
                            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                            ctx.lineTo(x, y + r);
                            ctx.quadraticCurveTo(x, y, x + r, y);
                            ctx.closePath();
                        };

                        drawRoundedRect(nameCtx, rectX, rectY, rectWidth, rectHeight, cornerR);
                        nameCtx.fillStyle = '#2a9df4';
                        nameCtx.globalAlpha = 0.92;
                        nameCtx.fill();
                        nameCtx.globalAlpha = 1;

                        const startY = NAME_TEXTURE_H / 2 - ((lines.length - 1) * lineHeight) / 2;
                        nameCtx.fillStyle = '#ffffff';
                        lines.forEach((line, idx) => {
                            const y = startY + idx * lineHeight;
                            nameCtx.fillText(line, NAME_TEXTURE_W / 2, y);
                        });
                    }
                }
                nameDataUrl = nameCanvas.toDataURL('image/png');
            } catch (err) {
                console.error('failed to compose name texture', err);
            }

            return { posterDataUrl, traitDataUrls, nameDataUrl, traits: traitLabels };
        }

    </script>

    <!-- 4) AR modal controller (uses #arMV already in your HTML) -->
    <script type="module">
        const modal = document.getElementById('arModal');
        const mv = document.getElementById('arMV');  // src set in HTML (e.g., "./assets/ar/avatar-billboard.glb")
        const closeBtn = document.getElementById('arClose');
        const arTitle = document.getElementById('arTitle');

        closeBtn.addEventListener('click', () => {
            modal.classList.remove('open');
            modal.setAttribute('aria-hidden', 'true');
        });

        // textureBundle: { posterDataUrl, nameDataUrl, traitDataUrls[] }, displayName: shown in modal header
        async function openARWithTexture(textureBundle, displayName = 'Character') {
            const modal = document.getElementById('arModal');
            const mv = document.getElementById('arMV');
            const arTitle = document.getElementById('arTitle');

            if (arTitle) arTitle.textContent = (displayName || 'Character').toUpperCase();
            if (modal) { modal.classList.add('open'); modal.setAttribute('aria-hidden', 'false'); }

            if (!mv) { console.warn('#arMV missing'); return; }

            const bundle = typeof textureBundle === 'string'
                ? { posterDataUrl: textureBundle, traitDataUrls: [] }
                : (textureBundle || {});
            const templateVariant = bundle.templateVariant === 'future' ? 'future' : 'oldSchool';
            const desiredGlbSrc = templateVariant === 'future'
                ? './assets/ar/animationtemplate2.glb'
                : './assets/ar/animationtemplate.glb';

            if (mv.getAttribute('src') !== desiredGlbSrc) {
                await new Promise(res => {
                    mv.addEventListener('load', res, { once: true });
                    mv.setAttribute('src', desiredGlbSrc);
                });
            } else if (!mv.model) {
                await new Promise(res => mv.addEventListener('load', res, { once: true }));
            }

            if (!mv.model) {
                await new Promise(res => mv.addEventListener('load', res, { once: true }));
            }

            const posterDataUrl = bundle.posterDataUrl || bundle.poster || bundle.pngDataUrl || null;
            const traitDataUrls = Array.isArray(bundle.traitDataUrls)
                ? bundle.traitDataUrls
                : Array.isArray(bundle.traits) ? bundle.traits : [];
            const nameDataUrl = bundle.nameDataUrl || bundle.name || null;

            window.__arUi?.setPreview(posterDataUrl);
            window.__arUi?.setStatus('ready', 'Tap “Open in AR” or the cube icon to place them.');

            const materials = mv.model?.materials || [];
            const posterMat = materials.find(m => m.name === 'PosterMaterial') || materials.find(m => m.name === 'AvatarMat');
            if (!posterMat) { console.warn('PosterMaterial not found in GLB'); return; }

            if (posterDataUrl) {
                const tex = await mv.createTexture(posterDataUrl);
                const pbr = posterMat.pbrMetallicRoughness;
                if (pbr?.baseColorTexture?.setTexture) pbr.baseColorTexture.setTexture(tex);
                else if (pbr?.setBaseColorTexture) pbr.setBaseColorTexture(tex);
                pbr?.setMetallicFactor?.(0.0);
                pbr?.setRoughnessFactor?.(1.0);
                posterMat?.setAlphaMode?.('BLEND');
            }

            const nameMat = materials.find(m => m.name === 'name');
            if (nameMat && nameDataUrl) {
                const nameTex = await mv.createTexture(nameDataUrl);
                const namePbr = nameMat.pbrMetallicRoughness;
                if (namePbr?.baseColorTexture?.setTexture) namePbr.baseColorTexture.setTexture(nameTex);
                else if (namePbr?.setBaseColorTexture) namePbr.setBaseColorTexture(nameTex);
                namePbr?.setMetallicFactor?.(0.0);
                namePbr?.setRoughnessFactor?.(1.0);
                nameMat?.setAlphaMode?.('BLEND');
            }

            const traitNames = ['trait1', 'trait2', 'trait3', 'trait4'];
            await Promise.all(traitNames.map(async (traitName, idx) => {
                const mat = materials.find(m => m.name === traitName);
                if (!mat) return;
                const dataUrl = traitDataUrls[idx];
                if (!dataUrl) return;
                const tex = await mv.createTexture(dataUrl);
                const pbr = mat.pbrMetallicRoughness;
                if (pbr?.baseColorTexture?.setTexture) pbr.baseColorTexture.setTexture(tex);
                else if (pbr?.setBaseColorTexture) pbr.setBaseColorTexture(tex);
                pbr?.setMetallicFactor?.(0.0);
                pbr?.setRoughnessFactor?.(1.0);
                mat?.setAlphaMode?.('BLEND');
            }));
        }


        // expose globally for the gallery script
        window.openARWithTexture = openARWithTexture;
    </script>


</body>

</html>